{"meta":{"title":"Daniel's Blog","subtitle":"A student of Software Engineering from Sun Yat-sen University","description":"Think twice, code once.","author":"Daniel Xu","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2019-08-31T02:45:00.000Z","updated":"2019-12-22T10:30:01.669Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于我 一名中山大学软件工程大三的学生，上过课的林林总总，什么都有点印象但又什么都没学会。 关于博客 本博客主要用于记录我在课程学习中的作业，以及遇到的问题与解决过程，便于查阅，希望能对于同样境遇的人有所帮助。 ​"},{"title":"文章分类","date":"2019-08-31T02:43:53.000Z","updated":"2019-12-22T10:30:01.669Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"文章标签","date":"2019-08-31T02:43:37.000Z","updated":"2019-12-22T10:30:01.669Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"display为inline-blobk的元素之间的间距","slug":"display为inline-blobk的元素之间的间距","date":"2020-03-26T12:30:06.000Z","updated":"2020-03-26T14:00:34.396Z","comments":true,"path":"2020/03/26/display为inline-blobk的元素之间的间距/","link":"","permalink":"http://yoursite.com/2020/03/26/display为inline-blobk的元素之间的间距/","excerpt":"","text":"现象当两个display值为inline-block的元素并列时，元素之间会出现神秘的间距。 inline元素也有相同现象。 原因造成「inline-block」元素空隙的本质是HTML中存在的空白符（white space）。由于对于西文来说，是使用空格作为单词之间的分界的，所以在HTML被解析时，inline或者inline-block元素的标签之间的空格或者换行被看成相当于文字间隙，产生了一些看不见的字符，CSS的white-space属性会作用于这些字符，产生了内容，占据了空间，产生了水平方向上的“间隙”效果； 因此，当inline或者inline-block元素的HTML标签之间存在换行或使用空格分隔的情况下会有间距。 解决方法假设HTML如下： 12345&lt;ul&gt; &lt;li&gt;item&lt;/li&gt; &lt;li&gt;item&lt;/li&gt; &lt;li&gt;item&lt;/li&gt;&lt;/ul&gt; 方法一：改变HTML结构既然原因是标签之间的空格（换行）产生的，那么去掉HTML元素之间的空格即可。以下几种结构都是可以的： 1234567891011121314151617181920212223242526&lt;!-- 1 --&gt;&lt;ul&gt; &lt;li&gt;item&lt;/li&gt;&lt;li&gt;item&lt;/li&gt;&lt;li&gt;item&lt;/li&gt;&lt;/ul&gt;&lt;!-- 2 --&gt;&lt;ul&gt; &lt;li&gt; item&lt;/li&gt;&lt;li&gt; item&lt;/li&gt;&lt;li&gt; item&lt;/li&gt;&lt;/ul&gt;&lt;!-- 3 --&gt;&lt;ul&gt; &lt;li&gt;item&lt;/li &gt;&lt;li&gt;item&lt;/li &gt;&lt;li&gt;item&lt;/li&gt;&lt;/ul&gt;&lt;!-- 4 --&gt;&lt;ul&gt; &lt;li&gt;item&lt;/li&gt;&lt;!-- --&gt;&lt;li&gt;item&lt;/li&gt;&lt;!-- --&gt;&lt;li&gt;item&lt;/li&gt;&lt;/ul&gt; 方法二：父元素的font-size属性设为0但由于font-size是继承属性，需要对所有子元素重新设定需要的font-size 方法三：子元素浮动对于子元素进行浮动，可以消除之间的间距，但是可能会对于布局产生影响。 方法四：设置letter-spacing或者word-spacing其中letter-spacing表示字符间距，word-spacing表示单词间距，随便设定一个较大的值即可。 123456789101112ul&#123; letter-spacing: -1000px;&#125;li&#123; letter-spacing: 0px;&#125;/* or */ul&#123; word-spacing: -1000px;&#125; 参考去除inline-block元素间间距的N种方法 关于display: inline-block产生的间隙","categories":[{"name":"CSS学习笔记","slug":"CSS学习笔记","permalink":"http://yoursite.com/categories/CSS学习笔记/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"前端路由的实现原理","slug":"前端路由的实现原理","date":"2020-02-23T11:34:42.000Z","updated":"2020-03-26T12:31:27.206Z","comments":true,"path":"2020/02/23/前端路由的实现原理/","link":"","permalink":"http://yoursite.com/2020/02/23/前端路由的实现原理/","excerpt":"","text":"SPA在传统的Web项目中，每个网页都对应了一个HTML文件，当我们向浏览器输入不同的URL时，服务器会返回不同的HTML文件，再由浏览器负责处理并呈现出不同的页面。但在现代的多数SPA（single page web application），即单页Web应用中，一个项目只有一个HTML页面，一旦加载完成就不会进行重新加载或跳转，取而代之的是通过使用JS动态的改变这单个HTML页面的内容，模拟多页面的跳转。 好处 由于在与用户的交互中不需要重新刷新页面，并且数据的获取也是异步执行的，页面更加流畅，用户的体验更好； 服务器压力小； 前后端分离开发。SPA和RESTful架构一起使用，后端不再负责模板渲染、输出页面工作，web前端和各种移动终端地位对等，后端API通用化。 坏处由于SPA是通过JS动态改变HTML内容实现的，页面本身的URL没有改变，这就导致了两个问题： 初次加载耗时增加； SPA无法记住用户的操作记录，刷新、前进、后退存在问题，需要自行实现导航。 只有一个URL对于SEO不友好 前端路由前端路由的产生就是为了解决SPA只有一个URL所带来的导航问题。 在使用Vue、React等前端框架时，我们都会发现项目中只有一个HTML文件，并且在该HTML中都存在一个根标签，起到了类似于容器的作用。容器内部的内容就由我们后续编写的每个视图决定，页面的切换就是容器中视图的切换。 前端路由的实现原理简单来说，就是在不跳转或者刷新页面的前提下，为SPA应用中的每个视图匹配一个特殊的URL，之后的刷新、前进、后退等操作均通过这个特殊的URL实现。为实现上述要求，需要满足： 改变URL且不会向服务器发起请求； 可以监听到URL的变化，并渲染与之匹配的视图。 主要有Hash路由和History路由两种实现方式。下文对两者的基本原理进行简单介绍，并分别实现了一个简易的路由Demo。 Hash路由Hash即URL中#号及其后面的字符，由于URL中Hash值的改变并不会向服务器发起请求，并且我们也可以通过ha shchange事件对其改变进行监听，因此我们就可以通过改变页面的Hash来实现不同视图的匹配与切换。 使用的API有： 123456789// 设置hashwindow.location.hash = 'xxxx';// 获取hashlet hash = window.location.hash;// 监听hash变化window.addEventListener('hashchange', function(event)&#123; let newURL = event.newURL; let oldURL = event.oldURL;&#125;, false); 创建路由类原理就是通过键值对的形式保存路由及对应要执行的回调函数，当监听到页面hash发生改变时，根据最新的hash值调用注册好的回调函数，即改变页面。 12345678910111213141516171819202122class Routers&#123; constructor()&#123; // 保存路由信息 this.routes = &#123;&#125;; this.currentUrl = ''; window.addEventListener('load', this.refresh, false); window.addEventListener('hashchange', this.refresh, false); &#125; // 用于注册路由的函数 route = (path, callback) =&gt; &#123; this.routes[path] = callback || function()&#123;&#125;; &#125; // 监听事件的回调，负责当页面hash改变时执行对应hash值的回调函数 refresh = () =&gt; &#123; this.currentUrl = location.hash.slice(1) || '/'; this.routes[this.currentUrl](); &#125;&#125;window.Router = new Routers(); 注册路由使用route方法添加对应的路由及其回调函数即可。以下代码实现了一个根据不同hash改变页面颜色的路由，模拟了页面的切换，在实际的SPA应用中，对应的就是页面内容的变化了。 12345678910111213141516171819var content = document.querySelector('body');function changeBgColor(color)&#123; content.style.background = color;&#125;// 添加路由Router.route('/', () =&gt; &#123; changeBgColor('yellow');&#125;);Router.route('/red', () =&gt; &#123; changeBgColor('red');&#125;);Router.route('/green', () =&gt; &#123; changeBgColor('green');&#125;);Router.route('/blue', () =&gt; &#123; changeBgColor('blue');&#125;); 完整Demo如下： See the Pen dyoOLNR by DanielXuuuuu (@DanielXuuuuu) on CodePen. History路由在H5之前，浏览器的history仅支持页面之前的跳转，包括前进和后退等功能。 在HTML5中，新增以下API： 123history.pushState(); // 添加新状态到历史状态栈history.replaceState(); // 用新状态代替当前状态history.state; // 获取当前状态对象 history.pushState()和history.replaceState()均接收三个参数： state：一个与指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数。如果不需要这个对象，此处可以填null。 title：新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null。 url：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址 二者的区别是history.pushState()是添加记录，而history.replaceState()是替换当前记录。但二者都不会触发页面跳转。 popstate事件：每当同一个文档的浏览历史（即history对象）出现变化时，就会触发popstate事件。但仅仅调用history.pushState()或者history.replaceState()并不会触发改事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用history的back、forward、go方法时才会触发。 由于history.pushState()和 history.replaceState()都具有在改变页面URL的同时，不刷新页面的能力，因此也可以用来实现前端路由。 创建路由类12345678910111213141516171819202122232425class Routers&#123; constructor()&#123; this.routes = &#123;&#125;; window.addEventListener('popstate', e =&gt; &#123; const path = e.state &amp;&amp; e.state.path; this.routes[path] &amp;&amp; this.routes[path](); &#125;) &#125; init(path)&#123; history.replaceState(&#123;path: path&#125;, null, path); this.routes[path] &amp;&amp; this.routes[path](); &#125; route(path, callback)&#123; this.routes[path] = callback || function()&#123;&#125;; &#125; go(path)&#123; history.pushState(&#123;path: path&#125;, null, path); this.routes[path] &amp;&amp; this.routes[path](); &#125;&#125;window.Router = new Routers(); 注册路由与之前类似，注册每个路由及其对应的回调函数。 12345678910111213141516171819function changeBgColor(color)&#123; content.style.background = color;&#125;Router.route(location.pathname, () =&gt; &#123; changeBgColor('yellow');&#125;);Router.route('/red', () =&gt; &#123; changeBgColor('red');&#125;);Router.route('/green', () =&gt; &#123; changeBgColor('green');&#125;);Router.route('/blue', () =&gt; &#123; changeBgColor('blue');&#125;);const content = document.querySelector('body');Router.init(location.pathname); 编写触发事件在使用hash实现的路由中，我们通过hashchange事件来监听hash的变化，但是上述代码中history的改变本身不会触发任何事件，因此无法直接监听history的改变来改变页面。因此，对于不同的情况，我们选择不同的解决方案： 点击浏览器的前进或者后退按钮：监听popstate事件，获取相应路径并执行回调函数 点击a标签：阻止其默认行为，获取其href属性，手动调用history.pushState()，并执行相应回调。 12345678const ul = document.querySelector('ul');ul.addEventListener('click', e =&gt; &#123; if(e.target.tagName === 'A')&#123; e.preventDefault(); Router.go(e.target.getAttribute('href')); &#125;&#125;) 完整Demo如下： See the Pen XWbNQzd by DanielXuuuuu (@DanielXuuuuu) on CodePen. 需要注意的是，以上操作中，页面始终没有进行跳转，只是通过history.pushState()显示了“假”的URL，同时由于history状态栈会进行改变，因此前进后退也会实现。 但倘若我们手动刷新，或输入URL直接进入页面的时候， 服务端是无法识别这个 URL 的。因为我们是单页应用，只有一个 html 文件，服务端在处理其他路径的 URL 的时候，就会出现404的情况。 所以，如果要应用 history 模式，需要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回单页应用的 HTML 文件。 对比基于hash的路由： 看起来比较丑 会导致锚点功能失效 但： 兼容性更好 无需服务器配合 参考面试官: 你了解前端路由吗? 「前端进阶」彻底弄懂前端路由","categories":[{"name":"前端学习笔记","slug":"前端学习笔记","permalink":"http://yoursite.com/categories/前端学习笔记/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"SPA","slug":"SPA","permalink":"http://yoursite.com/tags/SPA/"}]},{"title":"CSS布局学习｜两列等高布局","slug":"CSS布局学习-｜-两列等高布局","date":"2019-12-29T02:47:29.000Z","updated":"2020-02-18T14:35:32.613Z","comments":true,"path":"2019/12/29/CSS布局学习-｜-两列等高布局/","link":"","permalink":"http://yoursite.com/2019/12/29/CSS布局学习-｜-两列等高布局/","excerpt":"需求页面中经常会使用到多栏布局，但如果栏目带有背景颜色且各自的内容高度不一时，就会出现每一栏的底部不能够对其的情况，而我们所希望的是每一栏的底部可以平齐。","text":"需求页面中经常会使用到多栏布局，但如果栏目带有背景颜色且各自的内容高度不一时，就会出现每一栏的底部不能够对其的情况，而我们所希望的是每一栏的底部可以平齐。 解决方案HTML代码如下，代码中我手动指定了每栏的高度，实际中应由内容决定： 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;两列等高布局demo&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; #container&#123; overflow: hidden; background-color: hotpink; border: solid; &#125; #left&#123; width: 200px; height: 300px; float: left; background-color: red; &#125; #right&#123; width: 200px; height: 500px; float: left; background-color: green; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;div id=\"left\"&gt;&lt;/div&gt; &lt;div id=\"right\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 方案一：padding + margin给左右两列都加上以下样式： 12padding-bottom: 1000px;margin-bottom: -1000px; 以上代码给每列都设置了较大的底部正内边距，再设置绝对值相等的底部负外边距。由于对于父容器设置了overflow: hidden；，多出的内边距就会被隐藏掉，并且此时当任意一栏高度增加时导致父容器的高度增加时，较低的那一栏就会使用内边距进行补偿。又因为背景是包含内边距的，因此就实现了两列等高的假象。 缺点：每一栏的边框在底部无法正常显示，如下图所示。 方案二：表格布局父容器设置：display: table; 每一栏设置：display: table-cell; table元素中的table-cell元素默认是等高的。注意此时必须取消浮动，否则无效。同时，就算手动指定了不同高度，还是会等高。 方案三：flex弹性布局只需要在父容器中定义display: flex; flex中的伸缩项目默认为拉伸为父元素的高度。此时两列布局和等高都会自动实现。 注意此时也无需设置浮动（就算设置了也不影响），但此时如果手动给每栏都设定高度的话，高度还是会不一样的，正好和table布局完全相反。 方案四：JS高度计算需要设置浮动，然后把每栏高度都设为最高的那一栏的高度。 12345678910&lt;script src=\"https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(function()&#123; var m = Math.max( $('#left').height(), $('#right').height() ); $('#container div').height(m); &#125;)&lt;/script&gt; 在记录本篇文章中遇到的问题长串英文不换行在固定宽度的标签中，长单词不会自动换行，而中文会自动换行，因为 英文中将不包含空格、换行的连续文本认为是一个词，默认情况下不换行 中文中标点和文字都是独立的，所以会自动换行 解决方法： 12345678p &#123; word-wrap: break-word; /** *或者 *word-break: break-all; */&#125;","categories":[{"name":"CSS学习笔记","slug":"CSS学习笔记","permalink":"http://yoursite.com/categories/CSS学习笔记/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"3D-Game-Programming-Design | AR小游戏","slug":"3D-Game-Programming-Design-AR小游戏","date":"2019-12-16T08:58:28.000Z","updated":"2020-02-18T14:33:45.134Z","comments":true,"path":"2019/12/16/3D-Game-Programming-Design-AR小游戏/","link":"","permalink":"http://yoursite.com/2019/12/16/3D-Game-Programming-Design-AR小游戏/","excerpt":"3D游戏编程的第十一次作业： AR图片识别与虚拟按键小游戏 课程主页","text":"3D游戏编程的第十一次作业： AR图片识别与虚拟按键小游戏 课程主页 项目地址 演示视频 游戏简介这是一款极简的AR跑酷小游戏，通过虚拟按键进行控制，实现了类似Chrome浏览器在断网下可以玩的小恐龙游戏。 Vuforia的使用新版本的Vuforia使用和课程指导上已经有比较大的不同了，在这里简单说一下我在本次项目中关于Vuforia的使用。 官网注册这一步和老师上课说的还是一致的，我们需要现在Vuforia官网上申请license，并创建目标数据库。具体步骤就不再赘述了。 开启Vuforia支持首先需要启动Vuforia支持，勾选Edit-&gt;Project Settings-&gt;Player-&gt;XR Settings中的Vuforia Augmented Reality Supported选项。 添加AR Camera删除原来的相机，加入AR Camera： 在AR Camera的Inspector面板中，点击Open Vuforia Engine configuration选项，进入Vuforia设置面板，添加之前在官网注册好的License以及Databases，在该面板中还可以设置使用笔记本的前置还是后置摄像头。 添加ImageTarget加入ImageTarget对象，并选择好相应的Database。 此时，启动游戏便可以识别图片了，但是我们要想出现AR效果，即在图片上出现游戏人物，就需要在ImageTarget下添加一个子对象，并设置好相应的大小关系，如下图所示： 启动游戏后，已经可以成功识别，并且可以显示出我们在上一步添加的游戏对象。效果如下： 游戏设计本游戏中要实现的主要有两个方面：小飞龙的跳跃以及鸟的飞行，其中，鸟的飞行通过脚本控制鸟的预制体移动实现，而小飞龙的跳跃则通过虚拟按键实现。 鸟的飞行鸟的飞行脚本实现的比较简单，首先得到鸟的预制体对象，然后在每次Update函数中控制其位置按照既定的路线移动即可，一旦超出某个范围就让其回到原点，产生不断有鸟飞过的假象。需要注意的是，这里的位置都使用了相对位置，若使用绝对位置，在进行游戏时，如果相机移动了，鸟的位置也会移动。 123456789101112131415161718192021222324252627using UnityEngine;using System.Collections;public class birdGenerator : MonoBehaviour&#123; private GameObject bird; // Use this for initialization void Start() &#123; bird = Object.Instantiate(Resources.Load&lt;GameObject&gt;(\"bird\"), Vector3.zero, Quaternion.identity, null); bird.transform.parent = this.transform; bird.transform.localPosition = new Vector3(-0.2f, 0.1f, 0.5f); bird.transform.localScale *= 0.07f; bird.transform.Rotate(0, 180, 0, Space.Self); &#125; // Update is called once per frame void Update() &#123; bird.transform.localPosition -= new Vector3(0, 0, 0.015f); if (bird.transform.localPosition.z &lt; -0.4) &#123; bird.transform.localPosition = new Vector3(-0.2f, 0, 0.5f); &#125; &#125;&#125; 虚拟按键虚拟按键的使用方式和课件中有所不同，不再是一个预制体了，而是通过下图中Add Virtual Button的方式进行添加。在添加了虚拟按键之后，在游戏画面中是看不到的，为了使虚拟按钮可见，可以在按钮下添加3D物体以显示其位置。 虚拟按键的使用方式比较简单，主要是让类实现IVirtualButtonEventHandler中的OnButtonPressed和OnButtonReleased方法，并在虚拟按键中进行注册。在以下脚本中实现了，如果虚拟按键被按下，dragon游戏对象就进行原地跳跃（先上升后下降）。同时，通过pressed变量防止作弊现象（即一直按着虚拟按键，导致小火龙不下落的情况），只有当离开虚拟按键后再次按下，才会再次跳跃。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051using System.Collections;using System.Collections.Generic;using UnityEngine;using Vuforia;public class VBController : MonoBehaviour, IVirtualButtonEventHandler&#123; public GameObject dragon; public Vector3 target = new Vector3(-0.2f, 0, -0.2f); public float speed = 0.1f; public bool pressed = false; void Start() &#123; //在所有子物体类中找到所有VirtualButtonBehaviour组件 VirtualButtonBehaviour[] vbs = GetComponentsInChildren&lt;VirtualButtonBehaviour&gt;(); //在虚拟按钮中注册TrackableBehaviour事件 for (int i = 0; i &lt; vbs.Length; ++i) &#123; vbs[i].RegisterEventHandler(this); &#125; dragon = transform.Find(\"dragon\").gameObject; &#125; void Update() &#123; dragon.transform.localPosition = Vector3.MoveTowards(dragon.transform.localPosition, target, speed * Time.deltaTime); if (dragon.transform.localPosition == target) &#123; target = new Vector3(-0.2f, 0, -0.2f); &#125; &#125; public void OnButtonPressed(VirtualButtonBehaviour vb) &#123; Debug.Log(vb.VirtualButtonName + \" btn pressed\"); if(pressed == false) &#123; pressed = true; target = new Vector3(-0.2f, 0.4f, -0.2f); &#125; &#125; public void OnButtonReleased(VirtualButtonBehaviour vb) &#123; Debug.Log(vb.VirtualButtonName + \" btn released\"); pressed = false; &#125;&#125; 将以上两个脚本均挂载到ImageTarget上即可。 游戏画面游戏的画面如下，下图中的白色按钮即为可视化的虚拟按键，点击它，正义的小火龙就会起跳躲避邪恶的乌鸦！实际操作中，由于虚拟按键的原因，可能会出现控制不灵敏或者误触的现象，但总体上实现了预期效果。","categories":[{"name":"3D游戏编程","slug":"3D游戏编程","permalink":"http://yoursite.com/categories/3D游戏编程/"}],"tags":[{"name":"课程作业","slug":"课程作业","permalink":"http://yoursite.com/tags/课程作业/"},{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"}]},{"title":"Sevice-Computing | 初识Docker","slug":"Sevice-Computing-初识Docker","date":"2019-12-14T11:56:58.000Z","updated":"2020-02-18T14:31:52.648Z","comments":true,"path":"2019/12/14/Sevice-Computing-初识Docker/","link":"","permalink":"http://yoursite.com/2019/12/14/Sevice-Computing-初识Docker/","excerpt":"参考教程：每天5分钟玩转 Docker 容器技术","text":"参考教程：每天5分钟玩转 Docker 容器技术 容器简介什么是容器容器是一种轻量级、可移植、自包含的软件打包技术，使应用程序可以在几乎任何地方以相同的方式运行。开发人员在自己笔记本上创建并测试好的容器，无需任何修改就能够在生产系统的虚拟机、物理服务器或公有云主机上运行。 容器由两部分组成： 应用程序本身 依赖：比如应用程序需要的库或其他软件 容器和虚拟机的最大区别是虚拟机需要模拟整个操作系统，而容器运行在Host操作系统的用户空间，与操作系统的其他进程隔离。因此，所有的容器共享同一个 Host OS，这使得容器在体积上要比虚拟机小很多。另外，启动容器不需要启动整个操作系统，所以容器部署和启动速度更快，开销更小，也更容易迁移。 为什么使用容器使用容器使软件具备了超强的可移植能力。由于现如今的软件应用往往依赖多种服务，这些服务有自己的依赖，同时应用可能需要被部署或迁移到不同的环境，那么就需要一种通用的解决办法使得服务在不同的环境下都能顺利的运行。类比于运输行业的集装箱，集装箱解决了不同货物、不同运输环节下的不一致问题。Docker 将集装箱思想运用到软件打包上，为代码提供了一个基于容器的标准化运输系统。 优点对于开发人员 - Build Once, Run Anywhere 容器意味着环境隔离和可重复性。开发人员只需为应用创建一次运行环境，然后打包成容器便可在其他机器上运行。另外，容器环境与所在的 Host 环境是隔离的，就像虚拟机一样，但更快更简单。 对于运维人员 - Configure Once, Run Anything 只需要配置好标准的 runtime 环境，服务器就可以运行任何容器。这使得运维人员的工作变得更高效，一致和可重复。容器消除了开发、测试、生产环境的不一致性。 运行第一个容器环境选择： 管理工具：Docker Engine runtime：runc，Docker 的默认 runtime 操作系统：Ubuntu 18.04.3 LTS 配置 Docker 的 apt 源安装包，允许 apt 命令 HTTPS 访问 Docker 源。 12345$ sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ software-properties-common 添加 Docker 官方的 GPG 1$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 将 Docker 的源添加到 /etc/apt/sources.list 1234$ sudo add-apt-repository \\ &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot; 安装 Docker12$ sudo apt-get update$ sudo apt-get install docker-ce 运行第一个容器1docker run -d -p 80:80 httpd 注意该命令需要root权限，否则会提示permission denied。执行结果如下： 其过程可以简单的描述为： 从 Docker Hub 下载 httpd 镜像。镜像中已经安装好了 Apache HTTP Server。 启动 httpd 容器，并将容器的 80 端口映射到 host 的 80 端口。 打开浏览器输入Ubuntu的IP地址，出现如下界面，表明可以访问容器的 http 服务，容器运行成功！ 通过命令docker ps可以查看到当前启动的容器，使用docker stop 容器ID或容器名可以停止容器，使用命令docker images可以查看下载到本地的镜像。 镜像学习镜像是 Docker 容器的基石，容器是镜像的运行实例，有了镜像才能启动容器。 hello-world镜像hello-world镜像是Docker 官方提供的一个镜像，我们执行如下操作： 从上述运行的输出结果我们可以了解到镜像的运行原来，里面涉及到了容器客户端与容器服务器的交互，以及容器和镜像之间的关系。 镜像的分层结构有一种称为base的镜像，该镜像通常都是各种 Linux 发行版的 Docker 镜像，比如 Ubuntu, Debian, CentOS 等。base 镜像有两层含义： 不依赖其他镜像，从 scratch 构建。 其他镜像可以之为基础进行扩展。 Docker 支持通过扩展现有镜像，创建新的镜像。新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。这种做法的最大一个好处就是：共享资源。例如：有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。 但是，虽然低层的镜像被共享了，不同容器对其进行修改却不会造成混乱，所有的修改会被限制在单个容器内。当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。 添加文件：在容器中创建文件时，新文件被添加到容器层中。 读取文件：在容器中读取某个文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，打开并读入内存。 修改文件：在容器中修改已存在的文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后修改之。 删除文件：在容器中删除文件时，Docker 也是从上往下依次在镜像层中查找此文件。找到后，会在容器层中记录下此删除操作。 只有当需要修改时才复制一份数据，这种特性被称作 Copy-on-Write。可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。 Dockerfile构建镜像有两种方式，使用docker commit 命令或通过Dockerfile构建文件，一般使用Dockerfile的方式。 Dockerfile 是一个文本文件，记录了镜像构建的所有步骤。以下是一个Dockerfile的实例，该镜像在 ubuntu base 镜像中安装 vim 并保存为新镜像。 我们使用docker build命令通过这个Dockerfile构建新镜像： …此处省略apt-get install -y vim的过程。 …此处省略apt-get update的过程。 上图的结果对应以下流程： 运行docker build命令，-t将新镜像命名为ubuntu-with-vim，命令末尾的.指明build context为当前目录。Docker 默认会从build context中查找 Dockerfile 文件，我们也可以通过-f参数指定 Dockerfile 的位置。 然后是镜像真正的构建过程。 首先 Docker 将build context中的所有文件发送给Docker daemon。build context 为镜像构建提供所需要的文件或目录。Dockerfile 中的 ADD、COPY 等命令可以将build context中的文件添加到镜像。上图中，build context 为当前目录 /home/daniel/learn_docker，该目录下的所有文件和子目录都会被发送给Docker daemon。所以，使用build context就要小心了，不要将多余文件放到build context，特别不要把 /、/usr 作为build context，否则构建过程会相当缓慢甚至失败。 新镜像构建： Step 1：执行 FROM，将 ubuntu 作为 base 镜像。ubuntu 镜像 ID 为 775349758637。 Step 2：执行 RUN，安装 vim： 启动 ID 为 b59a91983696 的临时容器，在容器中通过 apt-get 安装 vim； 安装成功后，将容器保存为镜像，其 ID 为 7e72a9e24671，这一步底层使用的是类似 docker commit 的命令； 删除临时容器 b59a91983696 。 新镜像7e72a9e24671构建成功。 通过 docker images 查看镜像信息。 镜像 ID 为 7e72a9e24671，与构建时的输出一致。在上面的构建过程中，指令 RUN 的执行过程会在启动的临时容器中执行操作，并通过 commit 保存为新的镜像。 docker historyubuntu-with-vim 是通过在 base 镜像的顶部添加一个新的镜像层而得到的。这个新镜像层的内容由RUN apt-get update &amp;&amp; apt-get install -y vim生成。这一点我们可以通过docker history 命令验证。 docker history会显示镜像的构建历史，也就是 Dockerfile 的执行过程。ubuntu-with-vim 与 ubuntu 镜像相比，确实只是多了顶部的一层 7e72a9e24671，由apt-get命令创建，大小为 83.7MB。docker history也向我们展示了镜像的分层结构，每一层由上至下排列。 进入ubuntu-with-vim -it 参数的作用是以交互模式进入容器，并打开终端。412b30588f4a 是容器的内部 ID。 Dockerfile常用指令总结 指令 作用 FROM 指定 base 镜像。 MAINTAINER 设置镜像的作者，可以是任意字符串。 COPY 将文件从 build context 复制到镜像。 ADD 与 COPY 类似，从 build context 复制文件到镜像。不同的是，如果 src 是归档文件（tar, zip, tgz, xz 等），文件会被自动解压到 dest。 ENV 设置环境变量，环境变量可被后面的指令使用。 EXPOSE 指定容器中的进程会监听某个端口，Docker 可以将该端口暴露出来。 VOLUME 将文件或目录声明为 volume。 WORKDIR 为后面的 RUN, CMD, ENTRYPOINT, ADD 或 COPY 指令设置镜像中的当前工作目录。 RUN 在容器中运行指定的命令。 CMD 容器启动时运行指定的命令。Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效。CMD 可以被 docker run 之后的参数替换。 ENTRYPOINT 设置容器启动时运行的命令。&lt;br/Dockerfile 中可以有多个 ENTRYPOINT 指令，但只有最后一个生效。CMD 或 docker run 之后的参数会被当做参数传递给 ENTRYPOINT。","categories":[{"name":"服务计算","slug":"服务计算","permalink":"http://yoursite.com/categories/服务计算/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"}]},{"title":"3D Game Programming & Design - 游戏智能","slug":"3D-Game-Programming-Design-游戏智能","date":"2019-12-01T06:45:16.000Z","updated":"2020-02-18T14:33:31.610Z","comments":true,"path":"2019/12/01/3D-Game-Programming-Design-游戏智能/","link":"","permalink":"http://yoursite.com/2019/12/01/3D-Game-Programming-Design-游戏智能/","excerpt":"3D游戏编程的第十次作业： 牧师与恶魔 - 智能帮助版 课程主页","text":"3D游戏编程的第十次作业： 牧师与恶魔 - 智能帮助版 课程主页 项目地址 演示视频 简介在上一次的牧师与恶魔游戏中，我们实现了游戏对象的动作分离，即使用单独的动作管理器来管理动作，使得代码得以解耦，可扩展性更高。但这个游戏的难度对于初次接触这类游戏的人来说，还是有点难度的，因此，在学习了游戏智能后，本次实践中将在游戏中增加提示功能，来引导玩家完成这个游戏，使得游戏的体验更好。 要求 实现状态图的自动生成 讲解图数据在程序中的表示方法 利用算法实现下一步的计算 实现过程游戏状态图相信接触过算法知识的同学都应该清楚，在有的时候，当已知一个初始状态和一个结束状态，要求如何从这个初始状态开始，一步一步按照一个既定的规则转变成结束状态的问题，实际上就是一个对于过程中可能出现的状态的搜索过程，而我们要做的就是在整个状态空间中找到我们要的转换顺序。 同样的，对于我们这个游戏中的每一个阶段，我们都可以用一个状态$(P_{num}D_{num}B)$来表示。由于牧师和恶魔的数量固定的，同时为了表示方便，状态$(P_{num}D_{num}B)$仅表示当前游戏画面中右岸的情况，左岸的情况可以十分快速的求得。其中下标num表示当前右岸的牧师（恶魔）数量，B表示当前船是否在右岸。例如：游戏一开始时的状态为$(P_{3}D_{3}B)$，并且我们期望达到的目标状态为$(P_{0}D_{0})$。 有了状态，当然需要有状态转移，对于本游戏来说，状态的转移就是船的移动导致的右岸牧师和恶魔数量的变化，即状态的变化。状态转移条件表示为每移动一次船，船上的人员情况（总人数不超过2人）。 在明确了以上表示方法后，就可以画出整个游戏的状态转移图了，为了不重复造轮子，这里借用一下师兄画好的图： 上图中双箭头表示两个状态之间可以相互转换。其中两个*的状态表示游戏失败状态。可以看到，上图中左上角的状态即为我们的初始状态，从这个状态进行转移可以到达4个状态，但只有两个状态是可以最终通过变换达到目标（左下角）状态的。所以，当我们在游戏设计中给玩家增加游戏帮助功能时，就是从上图中玩家所处的当前状态入手，找到最佳的选择，并根据下一个状态自动执行的上下船操作。 状态图的表示与生成有了可视化的图，当然就需要把这个图用代码表示出来，而且根据要求，状态图需要自动生成。这里选择使用程序中表示图比较通用的方式—邻接表，邻接表的表示法需要两个类，一个类表示整个图，其中记录了图中所有的节点，另一个类表示单个节点，其中包含了与其相邻的节点集合。 具体的实现中，我使用了三个类来实现完整的状态图表示，包括节点类、图类，以及一个用于指示下一步如何走的move类。 move类move类简单的记录了船在一次移动中承载的牧师和恶魔数量，在后续的建图和获得下一步的过程中会使用到。 12345678910public class move&#123; public int priest_num; public int devil_num; public move(int pnum, int dnum) &#123; this.priest_num = pnum; this.devil_num = dnum; &#125;&#125; 状态节点stateNode类如前文所说，状态图中的状态表示的都是右岸中的人员以及船是否停靠情况。按照这个思路，我们可以定义以下类，这个类中除去状态节点所要包含的信息外，还包含了一个List数据结构，用于保存与其相邻的节点。类中有一个move()成员函数，可以得到当前状态在经过对应的移动后的新状态。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class stateNode&#123; public int priest_num; // 右岸牧师数量 public int devil_num; // 右岸魔鬼数量 public bool boat; // 船是否停靠在右岸 public List&lt;stateNode&gt; nextStates; // 相邻节点 public stateNode start; // 在搜索时用到，用于记录最短路径对应的起始步 public stateNode(int pnum, int dnum, bool boat) &#123; this.priest_num = pnum; this.devil_num = dnum; this.boat = boat; nextStates = new List&lt;stateNode&gt;(); &#125; // 加入相邻节点 public bool addNextState(stateNode nextState) &#123; foreach (stateNode node in nextStates) &#123; if (nextState == node) &#123; return false; &#125; &#125; nextStates.Add(nextState); return true; &#125; // 获得当前可选择的走法 public move[] getAvailableMove() &#123; move[] res = new move[nextStates.Count]; for(int i = 0; i &lt; nextStates.Count; i++) &#123; res[i] = new move(Mathf.Abs(nextStates[i].priest_num - this.priest_num), Mathf.Abs(nextStates[i].devil_num - this.devil_num)); &#125; return res; &#125; public void move(move mv) &#123; if (boat) &#123; this.priest_num -= mv.priest_num; this.devil_num -= mv.devil_num; &#125; else &#123; this.priest_num += mv.priest_num; this.devil_num += mv.devil_num; &#125; this.boat = !this.boat; &#125; // 船行驶向左岸，相当于右岸少人了 public static stateNode operator - (stateNode from, move mv) &#123; stateNode to = new stateNode(from.priest_num - mv.priest_num, from.devil_num - mv.devil_num, false); return to; &#125; // 船行驶回右岸，相当于右岸多人了 public static stateNode operator +(stateNode from, move mv) &#123; stateNode to = new stateNode(from.priest_num + mv.priest_num, from.devil_num + mv.devil_num, true); return to; &#125; // 重载==和!=运算符 public static bool operator ==(stateNode state1, stateNode state2) &#123; return state1.priest_num == state2.priest_num &amp;&amp; state1.devil_num == state2.devil_num &amp;&amp; state1.boat == state2.boat; &#125; public static bool operator !=(stateNode state1, stateNode state2) &#123; return state1.priest_num != state2.priest_num || state1.devil_num != state2.devil_num || state1.boat != state2.boat; &#125;&#125; 状态图stateGraph类状态图类包含了上述状态节点类，由于每个节点的相邻节点已经保存在自身的成员变量中了，状态图类只需要保存图中的节点即可，同样使用。 图生成函数generateGraph()的原理比较简单：先把起始节点加入我们的图中，然后对于List中的每个节点（即每一个状态），都会执行prosibleMove数组中的五种移动，并对得到的结果进行合法性判断（即会不会导致游戏失败），如果是合法的就加入图中并把节点相连（加入图中和加入节点的相邻节点列表都需要进行是否已存在的判断）。 获取下一步走法的函数getNextMove()也包含在这个图类中，该函数接收一个当前状态，返回最优的下一步走法。getNextMove()中又调用了getNextState()函数，该函数通过广度优先搜索（BFS）的方式查找到目标状态的最短路径。具体的实现见代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153// 状态图类public class stateGraph&#123; public List&lt;stateNode&gt; nodes; public move[] prosibleMove = &#123; new move(0, 1), new move(1, 0), new move(1, 1), new move(2, 0), new move(0, 2), &#125;; public stateNode startState; public stateNode endState; public stateGraph() &#123; nodes = new List&lt;stateNode&gt;(); startState = new stateNode(3, 3, true); endState = new stateNode(0, 0, false); generateGraph(); &#125; // 图生成函数 private void generateGraph() &#123; // 首先加入初始状态节点 nodes.Add(startState); for(int i = 0; i &lt; nodes.Count; i++) &#123; stateNode currentState = nodes[i]; foreach(move mv in prosibleMove) &#123; stateNode nextState; if (currentState.boat) &#123; nextState = currentState - mv; &#125; else &#123; nextState = currentState + mv; &#125; if (isLegalState(nextState)) &#123; nextState = addNewStateToGraph(nextState); currentState.addNextState(nextState); nextState.addNextState(currentState); &#125; &#125; &#125; &#125; // 将节点加入图中 private stateNode addNewStateToGraph(stateNode newState) &#123; // 先判断列表里当前有没有 foreach (stateNode state in nodes) &#123; if (state == newState) &#123; return state; &#125; &#125; nodes.Add(newState); return newState; &#125; private stateNode getGraphNode(stateNode newState) &#123; foreach (stateNode state in nodes) &#123; if (state == newState) &#123; return state; &#125; &#125; return null; &#125; // 验证状态是否合法 private bool isLegalState(stateNode state) &#123; return (state.priest_num &gt;= state.devil_num || state.priest_num == 0) &amp;&amp; ((3 - state.priest_num) &gt;= (3 - state.devil_num) || (3 - state.priest_num) == 0) &amp;&amp; (state.priest_num &lt;= 3 &amp;&amp; state.devil_num &lt;= 3) &amp;&amp; ((3 - state.priest_num) &lt;= 3 &amp;&amp; (3 - state.devil_num) &lt;= 3); &#125; public move getNextMove(stateNode currentState) &#123; // 找到图中真正的节点 currentState = getGraphNode(currentState); stateNode next = getNextState(currentState); return new move(Mathf.Abs(currentState.priest_num - next.priest_num), Mathf.Abs(currentState.devil_num - next.devil_num)); &#125; // 找到最短路径中当前状态的下一步 private stateNode getNextState(stateNode from) &#123; List&lt;stateNode&gt; alreadSearchState = new List&lt;stateNode&gt;(); alreadSearchState.Add(from); foreach (stateNode state in from.nextStates) &#123; // 判断是不是终点 if(state == endState) &#123; return state; &#125; else &#123; state.start = state; alreadSearchState.Add(state); &#125; &#125; for(int i = 1; i &lt; alreadSearchState.Count; i++) &#123; foreach(stateNode state in alreadSearchState[i].nextStates) &#123; // 判断是不是终点 if (state == endState) &#123; state.start = alreadSearchState[i].start; return state.start; &#125; else &#123; bool flag = false; // 检查是否已经搜索过 foreach (stateNode searchedState in alreadSearchState) &#123; if (state == searchedState) &#123; flag = true; break; &#125; &#125; if (!flag) &#123; state.start = alreadSearchState[i].start; alreadSearchState.Add(state); &#125; &#125; &#125; &#125; return null; &#125;&#125; 以上就完成了程序中对于状态图的自动生成，并可以根据当前状态得到最优的下一步。接下来就是需要对于原代码的一些部分进行调整即可。 调整原代码场记调整首先在场记中增加以下两个变量，并在初始化时对其进行初始化，由上文可知，此时整个图已经生成了。 12345public stateGraph graph; // 状态图public stateNode currState; // 当前游戏状态对应的状态节点，这个状态节点只是单纯的记录，和图中真正的记录节点不同graph = new stateGraph();currState = new stateNode(3, 3, true); 在每次我们移动船的时候（不管是手动移动还是自动移动），都需要改变当前的游戏状态节点。先统计移动时船上的人员情况，再通过我们的move类实现状态转移。 1234567891011121314151617181920public void MoveBoat()&#123; //当船为空，或者船或人物在运动时，不允许移动船 if (Boat.IsEmpty() || moving) return; RoleModel[] passengers = Boat.GetPassengers(); int priest_num = 0, devil_num = 0; for (int i = 0; i &lt; 2; i++) &#123; if (passengers[i] != null) &#123; if (passengers[i].IsGood()) priest_num++; else devil_num++; &#125; &#125; currState.move(new move(priest_num, devil_num)); actionManager.MoveBoat(Boat.GetBoat(), Boat.GetMoveDirection(), speed);&#125; 增加AI函数AI函数实现自动获取最佳的下一步，并自动执行上下船和开船操作。 由于在之前的设计中，我设定了人物和船在移动的时候都是有一段时间间隔的，在这个事件间隔中，玩家无法进行其他点击事件，但是这里如果在一个函数中，一下子把上下船和开船操作同时执行了，就会导致错误，所以我使用了协程的方式，yield return new WaitForSeconds(2f);使得每一个动作分阶段执行。但由于这样又变成了人为设定的时间间隔，有时候间隔会显得有点长，具体的效果可以看演示视频。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public void AI()&#123; if (!gaming || moving) return; StartCoroutine(AIroutine());&#125;IEnumerator AIroutine()&#123; // 搜索图得到最佳的下一步 move mv = graph.getNextMove(currState); Debug.Log(mv.priest_num); Debug.Log(mv.devil_num); // 自动执行上船下船操作 // 先统计当前船上的人员情况 int p_num = 0, d_num = 0; RoleModel[] passengers = Boat.GetPassengers(); for (int i = 0; i &lt; 2; i++) &#123; if (passengers[i] != null) &#123; if (passengers[i].IsGood()) p_num++; else d_num++; &#125; &#125; // 正数表示上岸，复数表示上船 p_num -= mv.priest_num; d_num -= mv.devil_num; int side = Boat.GetSide(); if (p_num == 0 &amp;&amp; d_num == 0) &#123; MoveBoat(); &#125; else &#123; // 先执行上岸操作，给船留出位置 if (p_num &gt; 0) &#123; int temp = 0; for (int i = 0; i &lt; 2; i++) &#123; if (passengers[i] != null) &#123; if (passengers[i].IsGood()) &#123; MoveRole(passengers[i]); yield return new WaitForSeconds(2f); temp++; if (temp == p_num) break; &#125; &#125; &#125; &#125; if (d_num &gt; 0) &#123; int temp = 0; for (int i = 0; i &lt; 2; i++) &#123; if (passengers[i] != null) &#123; if (!passengers[i].IsGood()) &#123; MoveRole(passengers[i]); yield return new WaitForSeconds(2f); temp++; if (temp == d_num) break; &#125; &#125; &#125; &#125; if (p_num &lt; 0) &#123; int temp = 0; for (int i = 0; i &lt; 3; i++) &#123; if (Priests[i].GetSide() == side &amp;&amp; !Priests[i].IsOnBoat()) &#123; MoveRole(Priests[i]); yield return new WaitForSeconds(2f); temp--; if (temp == p_num) break; &#125; &#125; &#125; if (d_num &lt; 0) &#123; int temp = 0; for (int i = 0; i &lt; 3; i++) &#123; if (Devils[i].GetSide() == side &amp;&amp; !Devils[i].IsOnBoat()) &#123; MoveRole(Devils[i]); yield return new WaitForSeconds(2f); temp--; if (temp == d_num) break; &#125; &#125; &#125; MoveBoat(); &#125;&#125; GUI调整增加按钮，调用AI()函数。 1234if (GUI.Button(new Rect(Screen.width / 2 + 40, 80, 60, 60), \"Help!\"))&#123; action.AI();&#125; 同时注意，在Restart按钮的点击事件中，需要重置游戏状态到最开始状态。 游戏画面","categories":[{"name":"3D游戏编程","slug":"3D游戏编程","permalink":"http://yoursite.com/categories/3D游戏编程/"}],"tags":[{"name":"课程作业","slug":"课程作业","permalink":"http://yoursite.com/tags/课程作业/"},{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"}]},{"title":"《Javascript高级程序设计》学习 | 闭包","slug":"《Javascript高级程序设计》学习-闭包","date":"2019-11-26T02:18:45.000Z","updated":"2020-02-18T14:27:37.628Z","comments":true,"path":"2019/11/26/《Javascript高级程序设计》学习-闭包/","link":"","permalink":"http://yoursite.com/2019/11/26/《Javascript高级程序设计》学习-闭包/","excerpt":"《Javascript高级程序设计》学习笔记三 这是我在学习Js红皮书的学习记录 本篇笔记主要记录了函数表达式、闭包方面的知识","text":"《Javascript高级程序设计》学习笔记三 这是我在学习Js红皮书的学习记录 本篇笔记主要记录了函数表达式、闭包方面的知识 函数表达式定义函数的两种方式： 函数声明 123function functionName(arg0, arg1, arg2)&#123; // dosomething&#125; 函数表达式 123var functionName = function(arg0, arg1, arg2)&#123; // dosomething&#125;; 虽然以上两种方式都创建了名为functionName的函数，但两者还是有区别的： 函数声明会产生函数声明提升。在全部代码执行前，解析器会先读取函数声明并添加到执行环境中，即相当于函数都是在代码一开始就声明了的。这意味着可以把函数声明放在调用它的语句之后，调用时也不会报未定义的错误； 函数表达式类似赋值语句，将一个匿名函数赋值给了一个变量。因此，与其他表达式一样，使用前必须先赋值。 函数递归递归通常是通过调用自身实现的，如下求阶乘的函数： 1234567function factorial(num)&#123; if(num &lt;= 1)&#123; return 1; &#125;else&#123; return num * factorial(num - 1); &#125;&#125; 但通过名字的直接调用自身可能会导致错误： 123var anotherFactorial = factorial;factorial = null;alert(anotherFactorial(4)); // 出错 上述代码把函数保存在另一个变量中，然后将factorial变量置空，那么接下来在调用函数时，由于函数中的factorial不再是函数了，所以会导致错误。此时，使用arguments.callee代替函数中的factorial可以解决问题，这是一个指向正在执行函数的指针（即指向自己）。 但严格模式下对于arguments.callee无法访问，可以通过以下方式： 1234567var factorial = (function f(num)&#123; if(num &lt;= 1)&#123; return 1; &#125;else&#123; return num * f(num - 1); &#125;&#125;); 以上代码创建了一个名为f()的❓命名函数表达式❓并赋值给变量factorial，此时即使把函数赋值给了另一个变量，名字f仍然有效。 闭包原理闭包是一个非常强大的功能，是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式就是在函数内部创建另一个函数，由于作用链的关系（内部函数的作用链包含外部函数的作用链），内部的函数可以访问外部函数中的变量。同时，即使内部函数被返回了并在其他地方调用，它仍然可以访问到原来的变量。 书中的例子如下（这个函数的功能是用于创建基于对象不同属性的比较函数，用于排序）： 1234567891011121314function createComparisonFunction(propertyName)&#123; return function(object1, object2)&#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; if(value1 &lt; value2)&#123; return -1; &#125;else if(value1 &gt; value2)&#123; return 1; &#125;else&#123; return 0; &#125; &#125;&#125; 之所以会产生内部函数返回后仍然可以访问外部函数变量这种神奇的现象，就要理解作用域链的相关知识： 当某个函数被调用时，会创建一个执行环境（execution context），其中包含相应的作用域链。然后使用arguments和其他命名参数的值初始化函数的活动对象（或变量对象，activation object）。活动对象存在于作用域链中，并且当前函数的活动对象排在第一位，外部函数的活动对象排在第二位…直至全局执行环境的活动对象。 当函数执行，需要读写变量时，就会到作用域链中查找对应的变量。作用域链本质上相当于一个指向变量对象的指针列表，只是引用但不实际包含变量对象。 全局环境的活动对象始终存在，而一般情况下函数执行完毕后，其局部活动对象就会被销毁。 但对于闭包，这个在一个函数内部定义的函数会将外部函数的活动对象添加到它的作用域链上，这样内部的函数才可以访问外部函数的变量。但在其被返回后，这个被返回的匿名函数的作用域链仍然引用着外部函数的活动对象，导致了外部函数的活动对象不会被销毁。也就是说，外部函数返回后，其执行环境的作用域链虽然销毁了，但它的活动对象仍然会留在内存中，直到匿名函数被销毁（置空），引用解除。 副作用变量我们回顾一下前文所说的，闭包现象的发生是因为保存了外部函数的整个活动对象，并且是通过作用域链引用这个对象。因此，其保存的不是一个特定时刻的特殊值，之后的调用只能取得外部函数任何变量的最终值。 123456789function createFunctions()&#123; var result = new Array(); for(var i = 0; i &lt; 10; i++)&#123; result[i] = function()&#123; return i; &#125;; &#125; return result;&#125; 上述代码中得到的函数数组都返回10，因为它们引用着同一个保存变量i活动对象，该对象中i的值为10。 当然，也有解决方法： 1234567891011function createFunctions()&#123; var result = new Array(); for(var i = 0; i &lt; 10; i++)&#123; result[i] = function(num)&#123; return function()&#123; return num; &#125;; &#125;(i); &#125; return result;&#125; 我们没有直接把闭包赋值给数组，而是定义了一个匿名函数，并把这个匿名函数立即执行后的结果赋给数组。由于函数参数是按值传递的，所以每次循环时，变量i的当前值被复制给变量num，而在匿名函数内部，又创建并返回了一个访问num的闭包，这样一来，result数组中每个函数就有自己的num变量副本了，不再是同一个！ this对象首先看以下代码： 123456789101112var name = \"The window\";var object = &#123; name: \"My Object\", getNameFunc: function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); //\"The window\"(非严格模式下) 以上代码在对象中定义了一个方法，该方法返回一个匿名函数，而匿名函数又返回this.name。但我们可以看到，最终的结果为The window，即匿名函数并没有取得外部函数的this对象。 原因是：每个函数在被调用时都会自动取得两个特殊变量：this和arguments，内部函数在搜索这两个变量时，只会搜索到自己的活动对象，也就是说内部函数不可能访问到外部函数的这两个变量，也就不存在保存不保存的问题了。 不过，也是有方法实现闭包对于外部函数的this对象的访问的： 12345678910111213var name = \"The window\";var object = &#123; name: \"My Object\", getNameFunc: function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); //\"My Object\"(非严格模式下) 以上代码将外部函数的this赋值给一个变量that，这样内部函数在搜索that变量时就可以访问到这个外部函数定义的变量了，同时返回后仍然引用着that。 内存需要注意的是，基于前文的分析我们可以看到，闭包会引用外部函数的整个活动对象，只要匿名函数存在，活动对象所占内存不会被回收。因此闭包会比其他函数占更多的内存，过度使用闭包可能会导致内存占用过多。 闭包使用模仿块级作用域123456function outputNumbers(count)&#123; for(var i = 0; i &lt; count; i++)&#123; alert(i); &#125; alert(i);&#125; Javascript中没有块级作用域，以上代码中在循环外还可以访问到变量i。原因是：在块语句中定义的变量，实际上是在包含函数中而非块语句中创建的，即变量i是定义在包含函数的活动对象中的，因此从有定义开始，在函数内部随处都可以访问。 通过闭包，我们还可以模仿块级作用域： 123(function()&#123; // 这里是块级作用域&#125;)(); 以上代码定义并立即调用了一个匿名函数并立即调用。将函数声明包含在一对圆括号中，表示实际上是一个函数表达式，即我们直接用函数表达式的值取代了函数名的位置。（注意一定要给函数体加括号，因为如果直接用function开头，会被认为是函数声明的开始，不允许后面立即跟圆括号，而函数表达式可以） 用这样的方式，相当于我们将变量定义在了匿名函数的活动对象中，而匿名函数在立即执行结束后就会被销毁了。而块级作用域又能访问到外部变量，因为它是一个闭包。 以上技术经常被用在全局作用域中以限制向全局作用域中添加过多的变量和函数，防止合作开发时过多的全局变量和函数导致的命名冲突。 私有变量严格来讲，JavaScript中没有私有成员的概念，所有对象属性都是公开的，但确实有一个类似私有变量的概念，即我们在函数中定义的变量在函数的外部是不能访问的。但结合我们上文提到的闭包，其作用就是在外部访问内部的变量，那么，我们是否可以利用闭包，实现用于访问私有变量的公有方法呢？答案是肯定的。这种方法称为特权方法，创建方式有两种： 在构造函数中定义12345678910111213function MyObject()&#123; // 私有变量和私有函数 var privateVariable = 10; function privateFunction()&#123; return false; &#125; // 特权方法 this.publicMethod = function()&#123; privateVariable++; return privateFunction(); &#125;&#125; 上述特权方法作为闭包有权访问在构造函数中定义的所有变量和函数。在用上述构造函数创建对象实例后，除了使用特权方法，是没有其他办法访问到私有变量和方法的，因此，使用这种技巧可以隐藏那些不应该被直接修改的数据。 在构造函数中定义特权方法有一个缺点，就是针对每个实例都会创建同样的新方法，因此，可以使用静态私有变量来实现特权方法。 在原型上定义静态私有变量通过在私有作用域中定义私有变量和函数： 1234567891011121314151617(function()&#123; // 私有变量和私有函数 var privateVariable = 10; function privateFunction()&#123; return false; &#125; // 构造函数 MyObject = function()&#123; &#125;; // 公有/特权方法 MyObject.prototype.publicMethod = function()&#123; privateVariable++; return privateFunction(); &#125;;&#125;)(); 这个模式创建了一个私有作用域，并在其中定义了私有变量和私有函数，然后定义了构造函数和公有方法，公有方法在原型上定义。 需要注意的是，这个模式在定义构造函数时使用的是函数表达式，因为函数声明只能创建局部函数，而我们需要在外部也可以使用这个构造函数。同时，表达式没有使用var也是出于同样的目的目的就是创建一个全局变量。（但也要知道，在严格模式下，给未经声明的变量赋值会导致错误，所以我们可以先提前声明好。） 这个模式和在构造函数中定义特权方法的主要区别在于实现了代码复用，但私有变量是由实例共享的。因为我们把特权方法定义在了原型上，所有实例使用这同一个函数，而这个特权方法作为闭包保存着对包含作用域活动对象的引用，所有私有变量也就是静态且共享的了，在任何实例中改变会影响其他所有实例。 模块模式创建单例前面的模式是为自定义类型创建私有变量和特权方法的，还有一种模块模式（module pattern）则是为单例创建私有变量和特权方法的。所谓单例，即只有一个实例对象，说白了就是以字面量方式创建的单例对象. 123456789101112131415var singleton = function()&#123; // 私有变量和私有函数 var privateVariable = 10; function privateFunction()&#123; return false; &#125; // 特权/公有方法和属性 return &#123; publicVariable: true, publicMethod: function()&#123; privateVariable++; return privateFunction(); &#125; &#125;;&#125;(); 看代码我们可以知道，这个模式返回了一个对象（对象字面量），返回的对象字面量只能访问公开的属性和方法，而公有方法作为闭包可以访问到私有变量和函数。注意到这里的函数立即执行不需要像上面一样套括号了，应该是这里是函数表达式的原因。 这种模式创建的单例都是Object的实例，因为是通过对象字面量的方式表示的。 创建特定类型的单例1234567891011121314151617181920var singleton = function()&#123; // 私有变量和私有函数 var privateVariable = 10; function privateFunction()&#123; return false; &#125; // 创建特定类型对象 var object = new CustomType(); // 添加特权/公有方法和属性 object.publicVariable = true, object.publicMethod = function()&#123; privateVariable++; return privateFunction(); &#125;; // 返回对象 return object;&#125;();","categories":[{"name":"Javascript学习笔记","slug":"Javascript学习笔记","permalink":"http://yoursite.com/categories/Javascript学习笔记/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"CSS布局学习 | 圣杯、双飞翼布局","slug":"CSS布局学习-圣杯、双飞翼布局","date":"2019-11-24T02:28:46.000Z","updated":"2020-02-18T14:31:31.451Z","comments":true,"path":"2019/11/24/CSS布局学习-圣杯、双飞翼布局/","link":"","permalink":"http://yoursite.com/2019/11/24/CSS布局学习-圣杯、双飞翼布局/","excerpt":"圣杯和双飞翼布局是最为经典和基础的两个布局方式了，两者的目的都是为了实现一个三栏的布局，其共同点如下： 两侧的宽度固定，中间的宽度能够自适应调整； 中间部分在DOM结构上优先，以便先行渲染 允许任意列的高度最高","text":"圣杯和双飞翼布局是最为经典和基础的两个布局方式了，两者的目的都是为了实现一个三栏的布局，其共同点如下： 两侧的宽度固定，中间的宽度能够自适应调整； 中间部分在DOM结构上优先，以便先行渲染 允许任意列的高度最高 圣杯布局DOM结构123456789&lt;body&gt; &lt;div id=\"header\"&gt;This is header&lt;/div&gt; &lt;div id=\"container\"&gt; &lt;div id=\"center\" class=\"column\"&gt;center&lt;/div&gt; &lt;div id=\"left\" class=\"column\"&gt;left&lt;/div&gt; &lt;div id=\"right\" class=\"column\"&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div id=\"footer\"&gt;This is footer&lt;/div&gt;&lt;/body&gt; 基本的DOM结构如上，主体的三列被包括在container中，注意center在最前面。 CSS布局我们首先给设定如下布局，先给每一栏设定不同的高度和背景颜色： 12345678910111213141516171819202122232425*&#123; padding: 0; margin: 0;&#125;#header, #footer&#123; background-color: gray; padding: 5px; text-align: center;&#125;#center&#123; background-color: blueviolet; height: 250px;&#125;#left&#123; background-color: bisque; height: 290px;&#125;#right&#123; background-color: aqua; height: 300px;&#125; 得到以下结果： 然后增加如下代码： 123456789101112131415161718192021222324252627/*为左右两列预留出空间*/#container&#123; padding-left: 200px; padding-right: 150px;&#125;/*分别为三列设定宽度以及浮动*/#container .column&#123; float: left;&#125;#center&#123; width: 100%; /*必须设为100%，否则由于浮动具有包裹性，此时div的宽度会收缩*/&#125;#left&#123; width: 200px;&#125;#right&#123; width: 150px;&#125;/*对底部的footer设置清除浮动，否则该元素会直接出现在header下方，因为浮动的元素已脱离文档流*/#footer&#123; clear:both;&#125; 此时结果如下： 不难理解，因为center元素的宽度为100%（此处的百分比是指子元素内容区域相对于父元素内容区域，因此，保留了父元素中之前预留的两侧padding），所以left和right都在其下面。接下来再添加如下代码： 123#left&#123; margin-left: -100%;&#125; 上述代码通过设置负外边距将left元素上移并覆盖住了center，可以看到如下图所示的结果。个人的理解是：当我们设置负外边距时，元素就会按照文档流反方向偏移（此处的三个浮动可以看作存在浮动流），当我们对于浮动元素设定margin-left: -100%，这里的100%相对的是上一个浮动元素的宽度，所以此时将左外边距设为-100%，就使得left元素产生了整体上移的效果。 最后添加如下代码，使用相对定位并向左偏移使left元素来到正确的位置，对于right元素，同样使用负外边距，： 12345678#left&#123; position: relative; right: 200px;&#125;#right&#123; margin-right: -150px;&#125; 最后，为了保证布局效果正常显示，需要给页面添加一个最小宽度，但不是200 + 150 = 350，由于之前的left元素使用了position:relative; right: 200px，所以，最小宽度应为350 + 200 = 550。添加如下代码就大功告成了： 123body &#123; min-width: 550px;&#125; 双飞翼布局DOM结构双飞翼布局的DOM结构如下，与圣杯布局有一点不同：container仅包含center元素，column也从center元素移动到了container上。 123456789&lt;body&gt; &lt;div id=\"header\"&gt;This is header&lt;/div&gt; &lt;div id=\"container\" class=\"column\"&gt; &lt;div id=\"center\"&gt;center&lt;/div&gt; &lt;/div&gt; &lt;div id=\"left\" class=\"column\"&gt;left&lt;/div&gt; &lt;div id=\"right\" class=\"column\"&gt;right&lt;/div&gt; &lt;div id=\"footer\"&gt;This is footer&lt;/div&gt;&lt;/body&gt; CSS布局首先完成基本的颜色、宽度、浮动设定。此时不再通过padding预留空间（由于DOM结构的改变），而是通过margin实现： 1234567891011121314151617181920212223242526272829303132333435363738394041*&#123; padding: 0; margin: 0;&#125;#header, #footer&#123; background-color: grey; padding: 5px; text-align: center;&#125;#container&#123; width: 100%;&#125;#center&#123; margin-left: 200px; margin-right: 150px; background-color: blueviolet; height: 250px;&#125;.column&#123; float: left;&#125;#left&#123; background-color: bisque; height: 290px; width: 200px;&#125;#right&#123; background-color: aqua; height: 300px; width: 150px;&#125;#footer&#123; clear: both;&#125; 得到结果如下，宽度为100%container占据了最上面一行，所以left和right元素都排在下面。注意center并没有设置宽度和浮动。 增加以下代码： 1234567#left&#123; margin-left: -100%;&#125;#right&#123; margin-left: -150px;&#125; 完成布局，得到和圣杯布局一样的效果： 对于双飞翼布局，由于没有用到相对定位，页面宽度最小可以为350px， 但是当页面宽度缩小到350px附近时，会挤占中间栏的宽度，使得其内容被右侧栏覆盖， 所以在设置最小页面宽度时，可以适当增加一些宽度以供中间栏使用。 比较 圣杯布局的DOM结构更加自然常见，只需要三个div即可。 双飞翼布局通过在center外增加一个div的方式，改padding为margin，并使得不需要使用相对定位，更加简单； 由于没有了相对定位，页面的最小宽度也有没有了上文所述的限制。 我们注意到在圣杯布局中，对于right元素，最后使用了margin-right: -150px;，而在双飞翼中则是margin-left: -150px;来实现。个人的观点是，由于在圣杯布局中，我们的方式是通过padding内边距预留空间，如果我们此时使用margin-left就会导致如下结果： 原因就是元素会紧挨着其在“元素流”（文档流或者浮动流）中的前一个元素，在圣杯布局中right的前一个浮动元素center，是在container的内容区里面，所以设置了负外边距后，不会按照预期的来到预留的位置，而是相对于center进入了内容区中。而在双飞翼中，它的前一个浮动元素是就是container，而container的宽度充满了整个屏幕，因此会得到正确结果。 PS：其实在圣杯布局中，对于右栏使用margin-left也是可以的，然后再用一下相对定位的，和左栏一样（实际上大多数网上的圣杯实现左右栏都是使用了相对定位）。至于为何使用margin-right会直接有这样的效果，目前我也还不是很清楚，还望看到本博客的人不吝赐教。 进阶：Flex布局在CSS3引入Flex（弹性盒子）布局后，要实现这种分栏布局就变得更加简单了： DOM结构123456789&lt;body&gt; &lt;div id=\"header\"&gt;This is header&lt;/div&gt; &lt;div id=\"container\"&gt; &lt;div id=\"center\"&gt;center&lt;/div&gt; &lt;div id=\"left\"&gt;left&lt;/div&gt; &lt;div id=\"right\"&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div id=\"footer\"&gt;This is footer&lt;/div&gt;&lt;/body&gt; CSS布局12345678910111213141516171819#container&#123; display: flex;&#125;#center&#123; background-color: blueviolet; flex: 1;&#125;#left&#123; background-color: bisque; flex: 0 0 200px; order: -1;&#125;#right&#123; background-color: aqua; flex: 0 0 150px;&#125; 对上述代码做一个简单解释：要使用flex布局，首先将父容器的display属性设为flex，然后其下的所有子元素自动变成容器成员—我们称为项目。对于容器，我们可以设置属性规定容器中的项目的排列方式，而上述代码中，我们直接通过设定项目的属性： order属性定义排列的属性，默认为0，我们将left的该属性设为-1，达到在最左边的目的。 flex属性是 flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。这里在center元素中将该值设为1，以实现自适应。 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。这里在left和right元素中将该值设为0，保持宽度不变。 flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。默认值为auto，即项目的本来大小。主轴默认为横轴，这里即用来设定固定宽度大小。 此处对于Flex布局只做相关的简单介绍，因为自己也是不太明白其原理，希望然后可以了解的更加深入。 感想CSS的世界真是千奇百怪，博大精深，作为刚开始学习的初学者，需要走的路还很多。 参考CSS布局奇淫巧计之-强大的负边距 Flex 布局教程：语法篇","categories":[{"name":"CSS学习笔记","slug":"CSS学习笔记","permalink":"http://yoursite.com/categories/CSS学习笔记/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"《Javascript高级程序设计》学习 | 对象、原型","slug":"《Javascript高级程序设计》学习-对象、原型","date":"2019-11-22T12:26:41.000Z","updated":"2020-02-18T14:30:11.128Z","comments":true,"path":"2019/11/22/《Javascript高级程序设计》学习-对象、原型/","link":"","permalink":"http://yoursite.com/2019/11/22/《Javascript高级程序设计》学习-对象、原型/","excerpt":"《Javascript高级程序设计》学习笔记二 这是我在学习Js红皮书的学习记录 本篇笔记主要记录了对象创建、原型链方面的知识","text":"《Javascript高级程序设计》学习笔记二 这是我在学习Js红皮书的学习记录 本篇笔记主要记录了对象创建、原型链方面的知识 类可以算是面向对象语言的一个标志，通过类的方式我们可以对于属性和方法进行良好的封装，并以此创建任意个具有相同属性和方法的对象。但ECMAScript中是没有类的概念的，在ECMAScript中，对象被定义为： 无序属性的集合，其属性可以包含基本值、对象或者函数。 因为每个属性都有名字，名字对应到一个值，ECMAScript的对象也可以看成一组名值对。每个对象都是基于一个引用类型创建的。 对象属性的特性对象的属性在创建时都带有一些特征值（characteristic），JavaScript可以通过这些特征值定义属性的行为。定义这些特性是为了实现 JavaScript _引擎用的，所以无法直接访问，为了表示特性是内部的，将其放在两队方括号中_。 ECMAScript属性分：数据属性和访问器属性两种属性。两者的差别见下文_year和year两个属性，前者为数据属性，后者为访问器属性。 数据属性：包含一个数据值的位置，在这个位置可以读取和写入值。数据属性包含以下4个特性： [[ configurable ]]：表示能否通过delete删除属性、能否修改属性特性、能否把属性改为访问器属性，默认为true。 [[ enumerable ]]：表示能否通过for-in循环返回属性，默认为true。 [[ writable ]]：表示能否修改属性，默认为true。 [[ value ]]：包含属性的数据值，默认为undefine。 修改属性默认特性的方法，通过ES5的Object.defineProperty()方法，该方法接收三个参数：属性所在的对象，属性的名字和一个描述符对象，如下： 123456789var person = &#123;&#125;;Object.defineProperty(person, \"name\", &#123; writable: false, value: \"Nicholas\"&#125;);alert(person.name); //\"Nicholas\"person.name = \"Greg\";alert(person.name); //\"Nicholas\" 以上例子把name属性改为只读，非严格模式下会忽略赋值操作，严格模式下会抛出错误。 对于configurable特性来说，一旦定义为false，就再也变不会true了，因为其表示不可配置。并且，此时如果调用defineProperty()方法修改除writable外的特性，都会导致错误 在调用defineProperty()，如果不指定任何特性，那么都会默认变为false。 访问器属性：不包含数据值，而包含一对getter和setter函数，有以下4个特性： [[ configurable ]]：表示能否通过delete删除属性、能否修改属性特性、能否把属性改为数据属性，默认为true。 [[ enumerable ]]：表示能否通过for-in循环返回属性，默认为true。 [[ get ]]：读取属性时调用的函数，默认为undefine。 [[ set ]]：写入属性时调用的函数，默认为undefine。 12345678910111213141516171819var book = &#123; _year: 2004, // 下划线只是一种记号，表明只能通过对象访问 edition: 1&#125;;Object.defineProperty(book, \"year\", &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if(newValue &gt; 2004)&#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;);book.year = 2005;alert(book.edition); // 2 使用访问器属性的常用方式就是如上所示的，通过设置一个值导致另一个值改变。 只指定getter意味着属性不能写，只指定setter意味着属性不能读 通过Object.defineProperties()方法可以通过描述符一次定义多个属性，使用Object.getOwnPropertyDescriptor()方法可以取得给定属性的描述符。 创建对象创建对象有以下几种方式： Object引用类型的构造函数或字面量。缺点：代码无法重复利用，每次都要重新写一遍 工厂模式。将创建的过程抽象和隐藏，封装在一个函数中，并在这个函数中返回创建的对象： 123456789101112function createPerson(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o;&#125;var person1 = createPerson(\"Nicholas\", 29, \"software Engineer\"); 优点：实现了创建多个相似对象的代码复用；缺点：没有解决对象识别问题（不知道这个对象的类型） 构造函数模式。像内置的Object和Array原生构造函数一样，我们可以自定创建构造函数（与普通函数唯一区别，通过new调用） 12345678910function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; alert(this.name); &#125;;&#125;var person1 = new Person(\"Nicholas\", 29, \"software Engineer\"); 通过这种方式创建对象会经历以下四步： 创建一个新对象 将构造函数的作用域赋给新对象，即this指向了新对象 执行构造函数里的代码，为新对象添加属性 返回新对象 通过构造函数创建的对象，可以通过以下方式标识对象类型。（比工厂模式好的原因） 123alert(person1.constructor == Person); //truealert(person1 instanceof Object); //truealert(person1 instanceof Person); //true 优点：可以将对象标识为特定的类型。仍有缺点：相同的方法，却在每个实例上都重新创建了一遍。解决方法： 把函数定义移到外面，创建一个全局函数，在构造函数中，都将这个全局函数赋值给对象的对应属性。由于函数名是指针，所以这样一来通过指向同一个全局函数实现共享。但是这样一来，函数一多就会需要创建很多全局函数，并且没有封装性可言。 通过使用原型模式解决 原型模式创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型所有实例共享的属性和方法。即prototype是通过调用构造函数创建的那个实例对象的原型对象 在使用构造函数时，通过将信息添加到构造函数的原型对象中，可以实现调用该构造函数创建的所有对象实例信息的共享。 1234567891011121314151617function Person()&#123;&#125;Person.prototype.name = \"Nicholas\";Person.prototype.age = 29;Person.prototype.job = \"software Engineer\";Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName(); //\"Nicholas\"var person2 = new Person();person2.sayName(); //\"Nicholas\"alert(person1.sayName == person2.sayName); // true 理解原型对象无论什么时候，只要创建一个函数，就会根据一组特定的规则为函数创建一个prototype属性，指向函数的原型对象，同时，在默认情况下，所有原型对象也会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。例如，前面的例子中，Person.prototype.constructor指向Person，因此，通过这个构造函数即Person()，我们还可以添加新的非共享的属性。 （看到这里可能有点糊涂了，大概的意思就是我们之前定义的这个函数可以看作某个原型对象的构造函数constructor，而这个原型对象可以通过函数的prototype访问，直接添加到原型对象上的函数被共享，而构造函数中创建的是非共享的属性） 创建自定义构造函数后，其原型对象初始默认只会取得constructor属性，其它的继承自Object。（constructor属性也是共享的，这也是上文曾出现的alert(person1.constructor == Person); //true的原因） 同时，当用构造函数创建了一个新实例后，这个新实例内部也有一个指针（内部属性）直接指向构造函数的原型对象。注意：实例的指针指向原型，不指向构造函数。整个指向逻辑见下图： 1234alert(Person.prototype.isPrototypeOf(person1)); //truealert(Object.getPrototypeOf(person1) == Person.prototype); //truealert(Object.getPrototypeOf(person1).name); //\"Nicholas\" 虽然实例对象中并没有属性，但我们之所以可以访问，是因为当代码读取属性是，如果没找到，就会向上搜索指针指向的原型对象，直到找到或没找到。使用hasOwnProperty()方法可以检测一个属性是否是存在实例中（该方法继承自Object）。 虽然可以通过实例对象访问保存在原型中的值，却不能重写，如果添加了重名属性，会屏蔽原型中的属性。因为此时直接找到了，不必到原型对象中找。（通过delete删掉实例对象中的属性可以恢复对于原型对象属性的访问）。 简便写法1234567891011function Person()&#123;&#125;Person.prototype = &#123; // constructor: Person name: \"Nicholas\"; age: 29; job: \"software Engineer\"; sayName: function()&#123; alert(this.name); &#125;&#125;; 以上无注释的写法将Person.prototye设置成了一个新对象，虽然最终结果相同，但是有一点例外，Person.prototye.constructor属性不再指向Person了。因为我们重写了原型对象，所以constructor属性变成了这个新对象的constructor属性（指向Object构造函数）。此时，前文出现的构造函数判断将返回false。 如果构造函数属性很重要，可以加上注释这一行，特意设回适当的值。 原型的动态性我们可以随时在原型对象上添加属性，由于实例对象保存着指向原型对象的指针，这个新添加的属性就可以被找到。但是，如果我们重写了原型对象，那么就有可能出错，因为实例对象的指针指向的仍然是最开始的那个原型对象。","categories":[{"name":"Javascript学习笔记","slug":"Javascript学习笔记","permalink":"http://yoursite.com/categories/Javascript学习笔记/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"《Javascript高级程序设计》学习 | 函数、变量、作用域","slug":"《Javascript高级程序设计》学习-函数、变量、作用域","date":"2019-11-19T05:42:20.000Z","updated":"2020-02-18T14:30:18.595Z","comments":true,"path":"2019/11/19/《Javascript高级程序设计》学习-函数、变量、作用域/","link":"","permalink":"http://yoursite.com/2019/11/19/《Javascript高级程序设计》学习-函数、变量、作用域/","excerpt":"《Javascript高级程序设计》学习笔记一 这是我在学习Js红皮书的学习记录 本篇笔记主要记录了函数、变量以及作用域方面的知识","text":"《Javascript高级程序设计》学习笔记一 这是我在学习Js红皮书的学习记录 本篇笔记主要记录了函数、变量以及作用域方面的知识 函数声明123function functionName(arg0, arg1, ..., argN)&#123; statements&#125; 不必指定返回值，任何函数在任何时候都可以通过return语句后跟要返回的值来实现返回值。当没有返回值时，将默认返回undefined。 参数ECMAScript所有参数传递传递的都是值。当传入基本类型的值时，被传递的值会被复制给一个局部变量；当传入引用类型的值（对象）时，会赋值这个值在内存中的地址，因此局部变量的变化会反映在函数外部。 ECMAScript函数不介意传递进来的参数个数，也不介意传进来的参数类型是什么，也就是说，例如定义的函数声明了接收两个参数，但在调用时可以传入0到n个任意参数。 之所以会允许上述情况发生，是因为ECMAScript中的参数在内部是用一个数组来表示的，函数接收到的永远是这个数组，也就不关心数组中的内容到底是什么了。而我们在函数中，可以通过arguments对象来访问这个数组，从而获得传递给函数的每一个参数（但arguments对象只是与数组类似，并不是Array的实例）。我们可以通过下标访问元素，使用length属性确定一共传进了多少个参数。 123function sayHi()&#123; alert(\"Hello \" + arguments[0] + \", \" + arguments[1]);&#125; 因此，如上代码所示，我们可以不显式的使用命名参数，直接通过arguments获取，这是ECMAScript函数的一个重要特点：即命名参数只提供便利，但不是必需的。 还有一点，arguments对象可以和命名参数一起使用，同时，它的值永远与对应的命名参数的值保持同步。如以下代码，每次执行都会重写第二个参数，将其值修改为10，不管传入的是多少。（注意：这不意味着这两个值会访问相同的内存空间，它们的内存空间是独立的，但值会同步） 1234function doAdd(num1, num2)&#123; arguments[1] = 10; alert(arguments[0] + num2);&#125; 没有传入值的命名参数将被赋予undefined值。 重载ECMAScript函数没有重载的概念，因为ECMAScript函数没有签名，其参数是由包含零个或多个值的数组表示的。 但我们可以通过arguments对象对于传入的参数个数进行判断，或者在函数中判断参数类型来模仿重载。 变量变量分为两种不同的数据类型的值：基本类型值和引用类型值。 基本类型值指的是五种基本数据类型，在内存中占据固定大小的空间，因此保存在栈内存中，都是按值访问的，可以操作保存在变量中的实际的值，复制时会创建副本。 引用类型的值是保存在堆内存中的对象，不允许直接访问，实际操作的是对象的引用，因此，引用类型的值是按引用访问的，复制的是指针，指向同一个对象。 对于引用类型的值，可以为其动态添加、改变、删除属性和方法。 引用类型类似于C\\C++的指针。但需要注意函数的参数都是按值传递的。 作用域执行环境定义了变量或函数有权访问的其他数据，每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。当某个执行环境的所有代码执行完毕后，环境被销毁，保存在其中的所有变量和函数也随之销毁。 全局执行环境是最外围的一个执行环境，在Web浏览器中，是window对象。 每个函数都有自己的执行环境，当执行流进入一个函数时，其环境就会推入一个环境栈中，执行后再出栈。当代码在执行中，会创建一个作用域链（scope chain），作用是保证对于执行环境有权访问的所有变量和函数的有序访问。作用域链前端是当前代码执行环境的变量对象，末端是全局执行环境。简单来说，就是查找变量定义时一级一级的往上找。 延长作用域的两种方式（会在作用域链的前端临时加一个变量对象）： try-catch语句的catch块：创建一个新的变量对象，其中包含的是被抛出的错误对象的声明 with语句：将指定对象添加到作用域链 没有块级作用域在例如C、C++等语言中，由花括号封闭的代码有自己的作用域，在里面声明的变量执行完后就被销毁了，但是Javascript并不会。如下，即使for循环结束后，创建的变量i依然存在。 1234for(var i = 0; i &lt; 10; i++)&#123; doSomething(i);&#125;alert(i); //10 使用var声明的变量会自动添加到最接近的环境中，函数内部就是函数的局部作用域。如果初始化变量时没有使用var，会自动加入到全局环境中。 1234567function add(num1, num2)&#123; sum = num1 + num2; return sum;&#125;var result = add(10, 20); // 30alert(sum); // 30 建议：初始化变量之前一定要先声明。在严格模式下，初始化未经声明的变量会导致错误。 垃圾收集机制这里顺带提一下Javascript具有自动垃圾收集机制，执行环境会管理代码执行过程中使用的内存，找出不再继续使用的变量，然后释放其占用的内存。垃圾收集器会在固定时间间隔执行这一操作。 垃圾收集器识别无用变量的策略： 标记清除：mark-and-sweep：给变量加上标记，例如进入环境，离开环境；（目前流行的方式） 引用计数：reference counting：顾名思义。但会导致循环引用的问题。解决：解除引用，即手动置为null。 由于Web浏览器可用内存通常较少，所以确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是执行时只保存必要的数据，一旦数据不再有用，将其值置为null来释放引用（dereferencing）。","categories":[{"name":"Javascript学习笔记","slug":"Javascript学习笔记","permalink":"http://yoursite.com/categories/Javascript学习笔记/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"MD5算法的C语言实现","slug":"MD5算法的C语言实现","date":"2019-11-18T12:08:47.000Z","updated":"2020-02-18T14:31:44.761Z","comments":true,"path":"2019/11/18/MD5算法的C语言实现/","link":"","permalink":"http://yoursite.com/2019/11/18/MD5算法的C语言实现/","excerpt":"算法原理概述MD5信息摘要算法，( Message-Digest Algorithm 5)，是一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值，用于确保信息传输完整一致。","text":"算法原理概述MD5信息摘要算法，( Message-Digest Algorithm 5)，是一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值，用于确保信息传输完整一致。 MD5算法使用little-endian（小端模式，即低位字节存在内存低地址），输入任意不定长度信息，算法都首先将其以512-bit进行分组（不足补位），每个512-bit的分组都和四个32-bit的数据一起，进行4次大循环（共64次迭代），并更新这四个32-bit数据。当所有分组都经过上述操作后，最后得到的四个32-bit联合输出固定的128位信息摘要。 算法基本流程算法的基本过程为：填充、分块、缓冲区初始化、循环压缩、得出结果。 总体结构MD5算法的总体结构如上图所示，结构应该还算是比较清晰的。与上次的DES加密算法不同，MD5的主体只有一个压缩函数，我们只需要写好这个函数中的内容，其他都比较简单。 我认为最主要的关键点有两个： 如何对于数据的填充和分块，特别是当输入是以一个文件而不是一个短字符串的形式时； 如何进行算法中的64次迭代。 下面对于算法的流程进行一些简单的说明： 数据填充和分块在长度为 K-bit 的原始消息数据尾部填充长度为 P-bit 的标识 100…0（一位1后面接若干位0），1 &lt; P &lt; 512（即至少要填充1个bit），使得填充后的消息位数为：K + P $\\equiv$ 448 (mod 512). 其中，如果当 K $\\equiv$448 (mod 512) 时，需要P = 512。 再向上述填充好的消息尾部附加 K 值的低64位(即K mod $2^{64}$)， 最后得到一个总长度位数为K + P+ 64 $\\equiv$ 0 (mod 512) 的消息。 得到填充完毕后的消息以后，我们就可以将其恰好分为 L 个 512-bit 的分组。（同时每个分组也可以再细分成16个 32-bit 的小分组，在程序中我们可以使用一个数组保存起来，这在后续的压缩循环中会使用到） 初始化初始化一个128-bit 的 MD 缓冲区，初始记为CV0，可以表示成4个32-bit 寄存器（A, B, C, D），后续的迭代始终在 MD 缓冲区进行，最后一步的128-bit 输出即为MD5算法的结果。 CV0的初始值为IV。寄存器(A, B, C, D) 置16进制初值作为初始向量IV，并采用小端存储(little-endian) 的存储结构（Intel x86系列CPU原本就采用Little Endian 方式存储）： A= 0x67452301 B= 0xEFCDAB89 C= 0x98BADCFE D= 0x10325476 压缩循环经过上述初始化步骤后，就可以开始执行算法的总体部分了，也就是压缩函数。 压缩函数每次都从CV（即上文提到的 128-bit 缓冲区）输入128位，从之前分好的消息分组中按顺序输入512位，完成4轮循环后，得到该轮压缩的128位结果，加到原来的缓冲区中，然后用下一分组继续上述步骤。（说具体一点，就是函数每次都从缓冲区(A, B, C, D)拿到四个数a, b, c, d，然后对于a, b, c, d进行压缩循环操作，把最后得到的结果a, b, c, d加到原来的(A, B, C, D)中，下一次函数执行再从(A, B, C, D)中拿数据） 上文提到函数共4轮循环，其中每轮循环分别固定不同的生成函数F, G, H, I，结合指定的T表元素T[]和消息分组的不同部分X[]做16次迭代运算， 生成下一轮循环的输入。即4轮循环共有64次迭代运算。每轮的逻辑如下： 生成函数g X[k]定义为当前处理消息分组的第k个(k= 0..15) 32位字（上文曾提到要将512-bit的分组再分为16个 32-bit 的小分组）。 k值的选取，设 j = i - 1： 第1轮循环：k = j，即顺序使用X[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] 第2轮循环：k = (1 + 5j) mod 16，即顺序使用X[1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12] 第3轮循环：k = (5 + 3j) mod 16，即顺序使用X[5, 8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2] 第4轮循环：k= 7j mod 16，即顺序使用X[0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9] T[i]T 表的第i个元素，每个元素为32位字；T表总共有64个元素，也称为加法常数。具体数值由于篇幅限制不再列出，具体可见程序。 CLS(s)循环左移s位。64次迭代中，每一次迭代左移的位数s如下： s[ 1..16] = { 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22 } s[17..32] = { 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20 } s[33..48] = { 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23 } s[49..64] = { 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21 } 加法循环中的加号表示的是模$2^{32}$ 加法。 模块分解按照算法的流程以及实际程序编写的需要，总体上我们可以分解得到以下模块： 读取文件和补位模块为了更贴合实际情况，本程序实现对于文本文件中内容的散列值计算，即可以支持任意位数字符。 我们无需按照死板的思维，一开始就马上统计文件所包含的比特数，然后马上计算出该如何如何进行补位。实际上，正是由于文件指针的存在，使得我们可以对于整个文件进行实时处理，也就是说我们只需要维护一个count变量，其初始值等于0。而我们每次读取文件64个字节（8*64=512），然后对于读到的这个消息分组即时进行压缩，同时累计位数到count上，直到我们读到文件的末尾，意味着此时不足512字节了。注意，由于我们一直在统计读到的位数，那么此时我们就得到了文件总大小，然后就可以对于最后的不足512bit的部分进行相应的补位操作了。 本文对应的程序就使用了上述方法。 主循环模块主循环就是上文提到的压缩循环部分，输入为文件读取模块得到的512bit文本数据和上一轮循环得到的CV值(A, B, C, D)，经过64次迭代后更新CV值，用于下一次新的循环。最终，随着文本读取的结束，也就得到了最终结果。 输入输出模块输入输出模块就比较简单了，由用户输入要进行处理的文件，最后输出得到的结果（32个16进制数的形式）。 数据结构本程序中没有使用到特殊的数据结构。只需要对于算法中会使用到的一些表和运算进行预先记录，可方便后续的操作，例如前文提到的生成函数、T表、循环左移的s值等等。 C语言源代码注释已经比较详细，这里不再进行说明。 md5.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#define _CRT_SECURE_NO_WARNINGS#ifndef MD5_H#define MD5_H#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;// MD5压缩函数4轮循环中使用的生成函数，每轮不同#define F(b, c, d) (((b) &amp; (c)) | ((~b) &amp; (d)))#define G(b, c, d) (((b) &amp; (d)) | ((c) &amp; (~d)))#define H(b, c, d) ((b) ^ (c) ^ (d))#define I(b, c, d) ((c) ^ ((b) | (~d)))// 循环左移#define LEFTROTATE(num, n) (((num) &lt;&lt; n) | ((num &gt;&gt; (32 - n))))// T表，32位字，一共有64个元素，对应64次迭代，也成为加法常数const uint32_t T[64] = &#123; 0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501, 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821, 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8, 0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70, 0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665, 0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1, 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391 &#125;;// 64次迭代运算采用的左循环移位的s值const uint32_t S[64] = &#123; 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21 &#125;;// 两个工具函数void int2byte(uint32_t val, uint8_t *bytes)&#123; bytes[0] = (uint8_t)val; bytes[1] = (uint8_t)(val &gt;&gt; 8); bytes[2] = (uint8_t)(val &gt;&gt; 16); bytes[3] = (uint8_t)(val &gt;&gt; 24);&#125;uint32_t byte2int(const uint8_t *bytes)&#123; return (uint32_t)bytes[0] | ((uint32_t)bytes[1] &lt;&lt; 8) | ((uint32_t)bytes[2] &lt;&lt; 16) | ((uint32_t)bytes[3] &lt;&lt; 24);&#125;// MD5主函数int MD5(const uint8_t* filepath, uint8_t *result) &#123; FILE *fp = NULL; uint8_t buffer[64]; uint8_t* temp = NULL; size_t count = 0, offset, i; // count用于记录总长度，补位的时候需要用到 uint32_t X[16]; int flag = 0; if ((fp = fopen(filepath, \"rb+\")) == NULL) &#123; printf(\"[ERROR] File in %s not found.\", filepath); return 0; &#125; // MD缓冲区CV，迭代在缓冲区进行 uint32_t A, B, C, D; // 初始向量IV，采用小端存储（Intel x86系列原本就采用了Little Endian方式存储） A = 0x67452301; B = 0xEFCDAB89; C = 0x98BADCFE; D = 0X10325476; while (!feof(fp)) &#123; memset(buffer, 0, sizeof(buffer)); // fread函数返回读取的次数，设定每次读取一个字符，就可以知道字符长度了 int len = fread(buffer, 1, 64, fp); // 更新文件总长度 count += len; // 当读取文件到末尾时，意味着需要进行补位操作了，此时读到的len可能不足512bit，也可能刚好等于512bit if (feof(fp)) &#123; flag = 1; // 因为恰好等于448bit不行，所以new_len直接等于len+1 int new_len; for (new_len = len + 1; new_len % 64 != 56; new_len++) ; // 还要增加64bit temp = (uint8_t*)malloc(new_len + 8); memcpy(temp, buffer, len); // 填充1000...0 temp[len] = 0x80; for (offset = len + 1; offset &lt; new_len; offset++) temp[offset] = 0; // 在末尾再附加总长度count的低64位，由于这里的count单位是byte，所以要乘以8 int2byte(count * 8, temp + new_len); int2byte(count &gt;&gt; 29, temp + new_len + 4); //参考了其他代码，count&gt;&gt;29相当于count*8&gt;&gt;32，但可以避免值溢出 len = new_len; &#125; // 虽然每次只读取512bit，但是还是采用这样的方式，可以防止最后的一次由于补位导致可能出现的 len &gt; 512bit 的情况（此时就要分两次了） for (offset = 0; offset &lt; len; offset += 64) &#123; // 读到结尾时，我们把补位后的数据存在了temp中，为了处理的统一，将temp中的数据保存到buffer上 if (flag == 1) &#123; memcpy(buffer, temp + offset, 64); &#125; // 保存512位的每32位分组，在X[k]时会用到 for (int i = 0; i &lt; 16; i++) &#123; X[i] = byte2int(buffer + i * 4); &#125; uint32_t a, b, c, d, temp, g, k; a = A; b = B; c = C; d = D; // 主循环，共四轮，每轮16次迭代，共64次迭代 for (i = 0; i &lt; 64; i++) &#123; if (i &lt; 16) &#123; g = F(b, c, d); k = i; &#125; else if (i &lt; 32) &#123; g = G(b, c, d); k = (1 + 5 * i) % 16; &#125; else if (i &lt; 48) &#123; g = H(b, c, d); k = (5 + 3 * i) % 16; &#125; else &#123; g = I(b, c, d); k = (7 * i) % 16; &#125; temp = d; d = c; c = b; b = b + LEFTROTATE((a + g + X[k] + T[i]), S[i]); a = temp; &#125; A += a; B += b; C += c; D += d; &#125; &#125; // 文件读取结束，释放内存 free(temp); // 把128位的最终结果转化为字节形式 int2byte(A, result); int2byte(B, result + 4); int2byte(C, result + 8); int2byte(D, result + 12); return 1;&#125;#endif // !MD5_H main.c12345678910111213141516171819202122232425262728#include \"md5.h\"int main() &#123; printf(\"\\n================== MD5 Message-Digest Algorithm ==================\\n\\n\"); printf(\"[INPUT] Enter the filepath: \"); // 输入文件路径 char filepath[256]; scanf(\"%s\", filepath); // 128位结果 uint8_t result[16]; int i; // 返回值不等于1表示有错误 if (MD5(filepath, result) == 1) &#123; printf(\"\\n[INFO] The result is: \"); //将字节通过无符号十六进制输出 for (i = 0; i &lt; 16; i++) &#123; printf(\"%2.2x\", result[i]); &#125; printf(\"\\n\"); &#125; system(\"pause\"); return 0;&#125; 编译运行结果 运行环境：💻Windows 10 1903 IDE：Visual Studio 2017 测试方式：和网上的已有MD5在线算法得到的结果进行比较，验证正确性。 注意：在使用本程序时，需要将文件放在正确的路径下 短字符串使用短字符Hello World!进行测试： 长字符串使用长达157个字符的字符串进行测试： 与网上的结果均一致，测试通过。","categories":[{"name":"信息安全","slug":"信息安全","permalink":"http://yoursite.com/categories/信息安全/"}],"tags":[{"name":"课程作业","slug":"课程作业","permalink":"http://yoursite.com/tags/课程作业/"},{"name":"MD5","slug":"MD5","permalink":"http://yoursite.com/tags/MD5/"},{"name":"c","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"3D-Game-Programming-Design-UI系统","slug":"3D-Game-Programming-Design-UI系统","date":"2019-11-17T07:07:11.000Z","updated":"2020-02-18T14:33:56.835Z","comments":true,"path":"2019/11/17/3D-Game-Programming-Design-UI系统/","link":"","permalink":"http://yoursite.com/2019/11/17/3D-Game-Programming-Design-UI系统/","excerpt":"3D游戏编程的第九次作业： 血条（Health Bar）的预制设计 课程主页","text":"3D游戏编程的第九次作业： 血条（Health Bar）的预制设计 课程主页 要求 分别使用 IMGUI 和 UGUI 实现 使用 UGUI，血条是游戏对象的一个子元素，任何时候需要面对主摄像机 分析两种实现的优缺点 给出预制的使用方法 项目地址 演示视频 实现过程IMGUIIMGUI主要通过HorizontalScrollbar实现，将其宽度作为血条的显示值。 具体代码如下，主要就是创建了一个矩形的HorizontalScrollbar作为血条，以及两个按钮，使得我们对于血量可以进行直观的增减，按钮触发的事件直接改变血量。 其中，参考以前师兄们的博客，使用了线性插值函数Lerp()，该函数有很多用法，这里的Mathf.Lerp(from : float, to : float, t : float) 函数基于浮点数t返回a到b之间的插值，t限制在0～1之间。当t = 0返回from，当t = 1 返回to。当t = 0.5 返回from和to的平均值。 因此，通过这个函数可以实现血量的平滑改变。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class IMGUI : MonoBehaviour&#123; public float blood; private float resultBlood; private Rect bloodBar; // 血条 private Rect addButton; // 加血按钮 private Rect reduceButton; // 扣血按钮 // Start is called before the first frame update void Start() &#123; // 初始值 blood = 50; resultBlood = 50; // 固定位置 bloodBar = new Rect(Screen.width / 2 -100, Screen.height / 4 - 10, 200, 20); reduceButton = new Rect(Screen.width / 2 - 160, Screen.height / 4 - 10, 40, 20); addButton = new Rect(Screen.width / 2 + 120, Screen.height / 4 - 10, 40, 20); &#125; // Update is called once per frame void Update() &#123; &#125; private void OnGUI() &#123; if(GUI.Button(addButton, \"+\")) &#123; resultBlood = resultBlood + 10.0f &gt; 100.0f ? 100.0f : resultBlood + 10.0f; &#125; if(GUI.Button(reduceButton, \"-\")) &#123; resultBlood = resultBlood - 10.0f &lt; 0.1f ? 0.0f : resultBlood - 10.0f; &#125; GUI.color = new Color(255f / 255f, 0f / 255f, 0f / 255f, 1f); //插值计算HP值 blood = Mathf.Lerp(blood, resultBlood, 0.05f); GUI.HorizontalScrollbar(bloodBar, 0.0f, blood, 0.0f, 100.0f); &#125;&#125; UGUI通过UGUI实现血条的方式参考老师的课程页面指导，步骤如下： 菜单 Assets -&gt; Import Package -&gt; Characters 导入人物资源 在层次视图，Context 菜单 -&gt; 3D Object -&gt; Plane 添加 Plane 对象 资源视图展开 Standard Assets :: Charactors :: ThirdPersonCharater :: Prefab 将 ThirdPersonController 预制拖放放入场景，改名为 Ethan 检查以下属性 Plane 的 Transform 的 Position = (0,0,0) Ethan 的 Transform 的 Position = (0,0,0) Main Camera 的 Transform 的 Position = (0,1,-10) 运行检查效果 选择 Ethan 用上下文菜单 -&gt; UI -&gt; Canvas, 添加画布子对象 选择 Ethan 的 Canvas，用上下文菜单 -&gt; UI -&gt; Slider 添加滑条作为血条子对象 选择 Ethan 的 Canvas，在 Inspector 视图 设置 Canvas 组件 Render Mode 为 World Space 设置 Rect Transform 组件 (PosX，PosY，Width， Height) 为 (0,2,160,20) 设置 Rect Transform 组件 Scale （x,y） 为 (0.01,0.01) 展开 Slider 选择 Handle Slider Area，禁灰（disable）该元素 选择 Background，禁灰（disable）该元素 选择 Fill Area 的 Fill，修改 Image 组件的 Color 为 红色 选择 Slider 的 Slider 组件 设置 MaxValue 为 100 设置 Value 为 75 经过上述步骤运行检查效果，发现血条会随着人物旋转。所以需要给 Canvas 添加以下脚本使其一直朝着相机方向。 12345public class LookAtCamera : MonoBehaviour &#123; void Update () &#123; this.transform.LookAt (Camera.main.transform.position); &#125;&#125; 到此，基础的血条就完成了，但为了显示其血量的变化，我在游戏场景增加了一个障碍物，并使得人物在撞到障碍物后血量会下降。 障碍物通过Cube实现，添加如下脚本： 1234567private void OnCollisionEnter(Collision collision)&#123; if(collision.gameObject.name == \"Ethan\") &#123; collision.gameObject.GetComponentInChildren&lt;Controller&gt;().collision(); &#125;&#125; 同时，给人物Ethan的子对象Canvas添加如下控制器代码，扣血的原理和IMGUI的原理相同，当Cube检测到碰撞后使得flag变量变为true，通过控制Slider的值实现血量的改变。 12345678910111213141516171819202122232425262728293031323334353637383940public class Controller : MonoBehaviour&#123; // UGUI的Slider对象 public Slider mainSlider; // 血量 private float currentBlood; private float resultBlood; // 碰撞检测 private bool flag; // Start is called before the first frame update void Start() &#123; // 初始血量 mainSlider.value = 80; currentBlood = mainSlider.value; resultBlood = currentBlood; &#125; // Update is called once per frame void Update() &#123; // 如果发生碰撞，扣血 if (flag) &#123; resultBlood = mainSlider.value - 20.0f &lt; 0.1f ? 0.0f : mainSlider.value - 20.0f; flag = false; &#125; // 平滑减少血量 currentBlood = Mathf.Lerp(currentBlood, resultBlood, 0.1f); mainSlider.value = currentBlood; &#125; public void collision() &#123; flag = true; &#125;&#125; 实现效果IMGUI UGUI 优缺点分析IMGUI个人认为IMGUI比较符合传统的UI写法，即通过代码的方式生成一个UI对象，并且定义与该对象进行交互时会发生的事件，这和我这个学期正在学习的IOS开发比较类似，这样的编程使得一切都在程序员的掌控之中，对于程序员来说应该是十分友好的。但缺点就是一切都是由代码生成，那么当需要的UI界面十分复杂时，就需要大量的代码支持，此时效率就会比较低下，调试起来也很困难，同时对于非程序员来说使用就比较困难，例如设计师们。 UGUIUGUI的出现就是为了解决IMGUI对于设计师们不够友好的困境，无需编码，而只需要创建UI组件并设置相应属性即可。这种所见即所得的设计方式让设计师们也能够参与程序的开发，脱离程序员的帮助。而其缺点，目前我使用的还比较简单，暂时还不太清楚有何缺点，可能对于作为程序员的我来说，创建的方式相对比较复杂，有很多属性的设置需要查看相应的文档才能清楚，不像程序中的方法调用那样直观。 预制的使用方法本项目中有IMGUI和UGUI两个预制，分别对应了各自的血条实现。使用方法如下： 当需要使用由IMGUI实现的血条时，只需要直接将该预制拖入场景即可。 当需要使用由UGUI实现的血条时，首先按照上文所说的搭建好基本场景，例如导入人物资源、设置 Plane 对象。然后将UGUI预制拖入到 Ethan对象下，成为其子对象，然后将UGUI预制对象下的 子对象Slider拖入对象的Controller.cs组件中的MainSlider属性即可。如需实现碰撞效果，需要再创建一个Cube对象，并为其添加脚本中的Collider.cs。","categories":[{"name":"3D游戏编程","slug":"3D游戏编程","permalink":"http://yoursite.com/categories/3D游戏编程/"}],"tags":[{"name":"课程作业","slug":"课程作业","permalink":"http://yoursite.com/tags/课程作业/"},{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"}]},{"title":"3D-Game-Programming-Design-粒子系统","slug":"3D-Game-Programming-Design-粒子系统","date":"2019-10-29T05:49:22.000Z","updated":"2020-02-18T14:32:46.205Z","comments":true,"path":"2019/10/29/3D-Game-Programming-Design-粒子系统/","link":"","permalink":"http://yoursite.com/2019/10/29/3D-Game-Programming-Design-粒子系统/","excerpt":"3D游戏编程课程的第八次作业： 参考 http://i-remember.fr/en 网站，实现“粒子光环” 课程主页","text":"3D游戏编程课程的第八次作业： 参考 http://i-remember.fr/en 网站，实现“粒子光环” 课程主页 粒子光环项目地址 演示视频 原网站效果图 鼠标悬停到中间的加号时，粒子光环会收缩；鼠标离开后，恢复原状。 实现步骤以下步骤是对于上图粒子光环的模仿，通过粒子流编程控制来实现。 参考博客 创建粒子系统经过仔细观察，可以发现，该网站的粒子光环实际上是由两个环叠加而成，其中，外环做顺时针运动，而内环做逆时针运动，且外环比内环更粗一些，粒子也更加稀疏一点。 因此，基于上述观察，我们创建两个环，项目结构如下： 外光环光环的实现还是非常简单的，编程控制粒子简单来说就是创建一个很大的粒子数组，并对于这个数组中的每个粒子，设定好其初始属性以及后续的运动轨迹：在下面这段脚本代码中，我们一共创建了4500个粒子，然后设定每个粒子的运动速度。随后，在一个范围内随机生成粒子的半径信息，在一个圆周范围内随机生成粒子相对于圆心的角度信息，并且保存，使得粒子的分布呈现圆环状。 在Update函数中，根据之前设定的速度值，随机改变角度信息并重新生成位置，然后通过SetParticles函数实现所有粒子位置的更新，形成粒子绕着圆周运动的视觉效果。 此外，Update函数中用于收缩变换的部分在后文会讲到，我们在nonCollectRadius和collectRadius两个数组中记录了粒子收缩前后的位置信息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class OuterRing : MonoBehaviour&#123; public ParticleSystem particleSystem; private ParticleSystem.Particle[] particles; private int particleNum = 4500; private float[] particleAngle; private float[] particleRadius; private float[] nonCollectRadius; private float[] collectRadius; private float minRadius = 3.0f, maxRadius = 4.8f; public float speed = 0.4f; public float collectSpeed = 2.5f; public bool isCollected = false; // Start is called before the first frame update void Start() &#123; particleSystem = this.GetComponent&lt;ParticleSystem&gt;(); particles = new ParticleSystem.Particle[particleNum]; particleAngle = new float[particleNum]; particleRadius = new float[particleNum]; nonCollectRadius = new float[particleNum]; collectRadius = new float[particleNum]; particleSystem.maxParticles = particleNum; particleSystem.Emit(particleNum); particleSystem.GetParticles(particles); for(int i = 0; i &lt; particleNum; i++) &#123; float radius = Random.Range(minRadius, maxRadius); float angle = Random.Range(0.0f, 360.0f); float rad = angle / 180 * Mathf.PI; particles[i].position = new Vector3(radius * Mathf.Cos(rad), radius * Mathf.Sin(rad), 0.0f); particleAngle[i] = angle; particleRadius[i] = radius; nonCollectRadius[i] = radius; collectRadius[i] = radius - 1.5f * (radius / minRadius); &#125; particleSystem.SetParticles(particles, particleNum); &#125; // Update is called once per frame void Update() &#123; for (int i = 0; i &lt; particleNum; i++) &#123; if (isCollected) &#123; if (particleRadius[i] &gt; collectRadius[i]) &#123; particleRadius[i] -= collectSpeed * (particleRadius[i] / collectRadius[i]) * Time.deltaTime; &#125; &#125; else &#123; if (particleRadius[i] &lt; nonCollectRadius[i]) &#123; particleRadius[i] += collectSpeed * (nonCollectRadius[i] / particleRadius[i]) * Time.deltaTime; &#125; else if (particleRadius[i] &gt; nonCollectRadius[i]) &#123; particleRadius[i] = particleRadius[i]; &#125; &#125; particleAngle[i] -= Random.Range(0, speed); float rad = particleAngle[i] / 180 * Mathf.PI; particles[i].position = new Vector3(particleRadius[i] * Mathf.Cos(rad), particleRadius[i] * Mathf.Sin(rad), 0.0f); &#125; particleSystem.SetParticles(particles, particleNum); &#125;&#125; 内光环内光环与外光环类似，改动的地方主要是粒子半径、数量的减少，粒子运动速度的变化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class InnerRing : MonoBehaviour&#123; public ParticleSystem particleSystem; private ParticleSystem.Particle[] particles; private int particleNum = 3000; private float[] particleAngle; private float[] particleRadius; private float[] nonCollectRadius; private float[] collectRadius; private float minRadius = 3.3f, maxRadius = 4.2f; public float speed = 0.2f; public float collectSpeed = 3f; public bool isCollected = false; // Start is called before the first frame update void Start() &#123; particleSystem = this.GetComponent&lt;ParticleSystem&gt;(); particles = new ParticleSystem.Particle[particleNum]; particleAngle = new float[particleNum]; particleRadius = new float[particleNum]; nonCollectRadius = new float[particleNum]; collectRadius = new float[particleNum]; particleSystem.maxParticles = particleNum; particleSystem.Emit(particleNum); particleSystem.GetParticles(particles); for (int i = 0; i &lt; particleNum; i++) &#123; float radius = Random.Range(minRadius, maxRadius); float shiftMinAngle = Random.Range(0, 135); float shiftMaxAngle = Random.Range(135, 180); float angle = Random.Range(shiftMinAngle, shiftMaxAngle); if (Random.Range(0, 100) &lt; 50) angle += 180.0f; float rad = angle / 180 * Mathf.PI; particles[i].position = new Vector3(radius * Mathf.Cos(rad), radius * Mathf.Sin(rad), 0.0f); particleRadius[i] = radius; particleAngle[i] = angle; nonCollectRadius[i] = radius; collectRadius[i] = radius - 1.5f * (radius / minRadius); &#125; particleSystem.SetParticles(particles, particleNum); &#125; // Update is called once per frame void Update() &#123; for (int i = 0; i &lt; particleNum; i++) &#123; if (isCollected) &#123; if (particleRadius[i] &gt; collectRadius[i]) &#123; particleRadius[i] -= collectSpeed * (particleRadius[i] / collectRadius[i]) * Time.deltaTime; &#125; &#125; else &#123; if (particleRadius[i] &lt; nonCollectRadius[i]) &#123; particleRadius[i] += collectSpeed * (nonCollectRadius[i] / particleRadius[i]) * Time.deltaTime; &#125; else if (particleRadius[i] &gt; nonCollectRadius[i]) &#123; particleRadius[i] = particleRadius[i]; &#125; &#125; particleAngle[i] += Random.Range(0, speed); float rad = particleAngle[i] / 180 * Mathf.PI; particles[i].position = new Vector3(particleRadius[i] * Mathf.Cos(rad), particleRadius[i] * Mathf.Sin(rad), 0.0f); &#125; particleSystem.SetParticles(particles, particleNum); &#125;&#125; 优化基于上述步骤，得到的结果如下： 可以看到，由于我们通过随机数生成两个圆的半径，所以粒子在圆环中的分布很均匀，导致内外粒子光环的边界比较分明，视觉效果并不是很好，因此，参考师兄的博客，对于两个光环中粒子的半径设定都做以下修改： 123456float midR = (maxRadius + minRadius) / 2;//最小半径随机扩大float rate1 = Random.Range(1.0f, midR / minRadius);//最大半径随机缩小float rate2 = Random.Range(midR / maxRadius, 1.0f);float radius = Random.Range(minRadius * rate1, maxRadius * rate2); 聚集效果原网站的效果是鼠标悬浮到圆心时整个光环就会向内聚集，离开后恢复。这里通过两个按钮实现类似的效果。 两个光环两个光环的实现方式类似，通过增加一个isCollected属性，控制其粒子的半径即可，在之前就已经提到，我们已经设定好了收缩和恢复前后的半径大小（我们使用固定值），那么直接根据isCollected属性判断当前所使用的半径即可。具体的Update函数如下： 12345678910111213141516171819202122232425262728void Update() &#123; for (int i = 0; i &lt; particleNum; i++) &#123; if (isCollected) &#123; if (particleRadius[i] &gt; collectRadius[i]) &#123; particleRadius[i] -= collectSpeed * (particleRadius[i] / collectRadius[i]) * Time.deltaTime; &#125; &#125; else &#123; if (particleRadius[i] &lt; nonCollectRadius[i]) &#123; particleRadius[i] += collectSpeed * (nonCollectRadius[i] / particleRadius[i]) * Time.deltaTime; &#125; else if (particleRadius[i] &gt; nonCollectRadius[i]) &#123; particleRadius[i] = particleRadius[i]; &#125; &#125; particleAngle[i] -= Random.Range(0, speed); float rad = particleAngle[i] / 180 * Mathf.PI; particles[i].position = new Vector3(particleRadius[i] * Mathf.Cos(rad), particleRadius[i] * Mathf.Sin(rad), 0.0f); &#125; particleSystem.SetParticles(particles, particleNum); &#125; UserGUI和之前类似，使用UserGUI实现“收”和“散”两个按钮负责与用户进行交互。由于本次项目比较简单，没有控制器来传递消息，这里就直接通过函数GetComponentsInChildren&lt;OuterRing&gt;()，并且将以下脚本挂载到Ring这个空对象上，就可以得到它两个子对象——内外两个光环，从而控制之前介绍的isCollected属性。 1234567891011121314151617181920212223242526272829public class UserGUI : MonoBehaviour&#123; private OuterRing[] outerRing; private InnerRing[] innerRing; private void Start() &#123; outerRing = GetComponentsInChildren&lt;OuterRing&gt;() as OuterRing[]; innerRing = GetComponentsInChildren&lt;InnerRing&gt;() as InnerRing[]; &#125; private void OnGUI() &#123; GUIStyle button_style; button_style = new GUIStyle(\"button\") &#123; fontSize = 15 &#125;; if(GUI.Button(new Rect(Screen.width - 150, Screen.height - 100, 100, 30), \"收\", button_style)) &#123; outerRing[0].isCollected = true; innerRing[0].isCollected = true; &#125; if(GUI.Button(new Rect(Screen.width - 150, Screen.height - 50, 100, 30), \"散\", button_style)) &#123; outerRing[0].isCollected = false; innerRing[0].isCollected = false; &#125; &#125;&#125; 最终效果","categories":[{"name":"3D游戏编程","slug":"3D游戏编程","permalink":"http://yoursite.com/categories/3D游戏编程/"}],"tags":[{"name":"课程作业","slug":"课程作业","permalink":"http://yoursite.com/tags/课程作业/"},{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"}]},{"title":"3D-Game-Programming-Design-模型与动画","slug":"3D-Game-Programming-Design-模型与动画","date":"2019-10-24T13:10:24.000Z","updated":"2020-02-18T14:32:52.675Z","comments":true,"path":"2019/10/24/3D-Game-Programming-Design-模型与动画/","link":"","permalink":"http://yoursite.com/2019/10/24/3D-Game-Programming-Design-模型与动画/","excerpt":"3D游戏编程课程的第七次作业： 智能巡逻兵 课程主页","text":"3D游戏编程课程的第七次作业： 智能巡逻兵 课程主页 智能巡逻兵项目地址 演示视频 设计要求 游戏设计要求： 创建一个地图和若干巡逻兵(使用动画)； 每个巡逻兵走一个3~5个边的凸多边型，位置数据是相对地址。即每次确定下一个目标位置，用自己当前位置为原点计算； 巡逻兵碰撞到障碍物，则会自动选下一个点为目标； 巡逻兵在设定范围内感知到玩家，会自动追击玩家； 失去玩家目标后，继续巡逻； 计分：玩家每次甩掉一个巡逻兵计一分，与巡逻兵碰撞游戏结束； 程序设计要求： 必须使用订阅与发布模式传消息 工厂模式生产巡逻兵 设计实现巡逻兵巡逻兵数据123456public class PatrolData : MonoBehaviour&#123; public int manageFloor; // 管理的房间 public int plyerFloor; // 玩家当前所在房间 public Vector3 initPosition; // 初始位置&#125; 巡逻兵工厂巡逻兵工厂负责产生一定数量、预定位置的巡逻兵，并记录每个巡逻兵相应的管辖范围。 1234567891011121314151617181920212223242526272829303132333435public class PatrolFactory : MonoBehaviour&#123; private GameObject patrolPrefab = null; private Vector3[] position = new Vector3[6]; //记录巡逻兵的位置 private List&lt;GameObject&gt; patrols = new List&lt;GameObject&gt;(); public List&lt;GameObject&gt; GetPatrols() &#123; int[] pos_x = &#123; -10, 3, 18, -11, 3, 15 &#125;; int[] pos_z = &#123; -18, -15, -15, 12, 10, 13 &#125;; for(int i = 0; i &lt; 6; i++) &#123; position[i] = new Vector3(pos_x[i], 0, pos_z[i]); patrolPrefab = Object.Instantiate(Resources.Load&lt;GameObject&gt;(\"Prefabs/patrol2\"), position[i], Quaternion.identity); patrolPrefab.name = \"patrol\" + i; patrolPrefab.AddComponent&lt;PatrolData&gt;(); patrolPrefab.GetComponent&lt;PatrolData&gt;().manageFloor = i + 1; patrolPrefab.GetComponent&lt;PatrolData&gt;().initPosition = position[i]; patrols.Add(patrolPrefab); &#125; return patrols; &#125; public void Reset() &#123; for(int i = 0; i &lt; patrols.Count; i++) &#123; patrols[i].transform.position = position[i]; patrols[i].GetComponent&lt;Animator&gt;().SetBool(\"shoot\", false); &#125; &#125;&#125; 巡逻兵动作巡逻兵动作一共有两种：普通巡逻和追踪敌人，动作的切换通过回调函数实现。 巡逻动作每个巡逻兵都按照简单的矩形路线不断重复运动，每当到达指定的顶点就换方向。在每次巡逻的同时，判断玩家所在区域是不是自己管辖的区域。如果是，则停止巡逻，开始追击玩家（销毁当前动作，执行回调函数）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class PatrolMoveAction : SSAction&#123; private float posX, posZ; private float rectLength; // 边长 private enum Dirction &#123; EAST, NORTH, WEST, SOUTH &#125;; // 巡逻的四个方向 private float speed = 2f; // 巡逻速度 private bool reach = true; // 是否到达目的地 private Dirction dirction = Dirction.EAST; // 移动的方向 private PatrolData data; // 巡逻兵的数据 public static PatrolMoveAction GetSSAction(Vector3 location) &#123; PatrolMoveAction action = CreateInstance&lt;PatrolMoveAction&gt;(); action.posX = location.x; action.posZ = location.z; action.rectLength = Random.Range(5, 8); return action; &#125; public override void Start() &#123; data = this.gameObject.GetComponent&lt;PatrolData&gt;(); &#125; public override void Update() &#123; //防止碰撞发生后的旋转 if (transform.localEulerAngles.x != 0 || transform.localEulerAngles.z != 0) &#123; transform.localEulerAngles = new Vector3(0, transform.localEulerAngles.y, 0); &#125; if (transform.position.y != 0.5f) &#123; transform.position = new Vector3(transform.position.x, 0.5f, transform.position.z); &#125; // 移动 Move(); // 如果所在房间相同，摧毁当前动作并回调 if (data.manageFloor == data.plyerFloor) &#123; this.destory = true; this.callback.SSActionEvent(this, SSActionEventType.Compeleted, 0 ,\"follow player\", this.gameObject); &#125; &#125; public void Move() &#123; if (reach) &#123; // 如果已到达，就换方向 switch (dirction) &#123; case Dirction.EAST: posX -= rectLength; break; case Dirction.NORTH: posZ += rectLength; break; case Dirction.WEST: posX += rectLength; break; case Dirction.SOUTH: posZ -= rectLength; break; &#125; reach = false; &#125; //面朝目的地 this.transform.LookAt(new Vector3(posX, 0.5f, posZ)); //计算距离 float distance = Vector3.Distance(transform.position, new Vector3(posX, 0.5f, posZ)); if (distance &gt; 1) &#123; transform.position = Vector3.MoveTowards(this.transform.position, new Vector3(posX, 0.5f, posZ), speed * Time.deltaTime); &#125; else &#123; dirction = dirction + 1; if (dirction &gt; Dirction.SOUTH) &#123; dirction = Dirction.EAST; &#125; reach = true; &#125; &#125;&#125; 追踪玩家动作追踪动作比较简单，创建该动作时会传入玩家对象，之后都朝着玩家的位置移动即可。在动作执行的同时判断玩家是否离开管辖区域，如果离开了，就重新开始巡逻（销毁当前动作，执行回调函数）。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class PatrolFollowAction : SSAction&#123; private GameObject player; // 创建动作时传入玩家对象，以便对玩家进行追踪 private float speed = 3f; // 追踪玩家的速度 private PatrolData data; // 巡逻兵数据 public static PatrolFollowAction GetSSAction(GameObject player) &#123; PatrolFollowAction action = CreateInstance&lt;PatrolFollowAction&gt;(); action.player = player; return action; &#125; public override void Start() &#123; data = this.gameObject.GetComponent&lt;PatrolData&gt;(); &#125; public override void Update() &#123; if (transform.localEulerAngles.x != 0 || transform.localEulerAngles.z != 0) &#123; transform.localEulerAngles = new Vector3(0, transform.localEulerAngles.y, 0); &#125; if (transform.position.y != 0.5f) &#123; transform.position = new Vector3(transform.position.x, 0.5f, transform.position.z); &#125; transform.position = Vector3.MoveTowards(this.transform.position, player.transform.position, speed * Time.deltaTime); //追踪时面朝玩家 this.transform.LookAt(player.transform.position); //丢失目标，停止追踪 //如果侦察兵没有跟随对象，或者需要跟随的玩家不在侦查兵的区域内 if (data.manageFloor != data.plyerFloor) &#123; this.destory = true; this.callback.SSActionEvent(this, SSActionEventType.Compeleted, 1, \"stop follow\", this.gameObject); &#125; &#125;&#125; 巡逻兵动作管理器动作管理器主要负责的是在游戏的开始让巡逻兵开始巡逻，并通过回调函数处理不同的情况：根据回调的参数不同，进行巡逻动作和追踪动作的切换。同时，在由追踪切换为巡逻时，需要发布玩家逃脱的消息，进行后续的处理。 123456789101112131415161718192021222324252627282930313233343536373839404142public class PatrolActionManager : SSActionManager, ISSActionCallback&#123; //巡逻动作 private PatrolMoveAction move; private SceneController sceneController; protected new void Start() &#123; sceneController = SSDirector.GetInstance().CurrentSceneController as SceneController; &#125; public void PatrolMove(GameObject patrol) &#123; move = PatrolMoveAction.GetSSAction(patrol.transform.position); this.RunAction(patrol, move, this); &#125; #region ISSActionCallback implementation public void SSActionEvent(SSAction source, SSActionEventType events = SSActionEventType.Compeleted, int intParam = 0, string strParam = null, GameObject objectParam = null) &#123; //回调函数,动作执行完后调用 if (intParam == 0) &#123; //开始跟随玩家 PatrolFollowAction follow = PatrolFollowAction.GetSSAction(sceneController.player); this.RunAction(objectParam, follow, this); &#125; else &#123; //丢失目标，继续巡逻 PatrolMoveAction move = PatrolMoveAction.GetSSAction(objectParam.gameObject.GetComponent&lt;PatrolData&gt;().initPosition); this.RunAction(objectParam, move, this); //玩家逃脱 Singleton&lt;GameEventManager&gt;.Instance.PlayerEscape(); &#125; &#125; #endregion&#125; 玩家玩家移动玩家移动的实现通过获取键盘输入并执行相应的函数完成。这里实现的移动可以通过方向键来控制，上下表示前进和后退，左右表示转向，类似于汽车游戏。 123456789101112131415161718192021222324252627282930// UserGUI.csvoid Update()&#123; float transitionX = Input.GetAxis(\"Horizontal\"); float transitionZ = Input.GetAxis(\"Vertical\"); //移动玩家 action.MovePlayer(transitionX, transitionZ); timeCounter = action.GetTime();&#125;// SceneController.cspublic void MovePlayer(float x, float z)&#123; if (!gameOver) &#123; //移动和旋转 player.transform.Translate(0, 0, z * playerSpeed * Time.deltaTime); player.transform.Rotate(0, x * 135f * Time.deltaTime, 0); //防止碰撞带来的移动 if (player.transform.localEulerAngles.x != 0 || player.transform.localEulerAngles.z != 0) &#123; player.transform.localEulerAngles = new Vector3(0, player.transform.localEulerAngles.y, 0); &#125; if (player.transform.position.y != 0.5f) &#123; player.transform.position = new Vector3(player.transform.position.x, 0.5f, player.transform.position.z); &#125; &#125;&#125; 碰撞事件玩家与地图碰撞为不同的房间添加以下脚本，每个房间的sign值不同，通过玩家与不同房间地面的碰撞更新玩家的位置。 123456789101112131415161718public class AreaCollide : MonoBehaviour&#123; public int sign = 0; SceneController sceneController; private void Start() &#123; sceneController = SSDirector.GetInstance().CurrentSceneController as SceneController; &#125; void OnTriggerEnter(Collider collider) &#123; //标记玩家进入自己的区域 if (collider.gameObject.name == \"player\") &#123; Debug.Log(\"player enter floor \" + sign); sceneController.floorNumber = sign; &#125; &#125;&#125; 玩家与金币碰撞为金币添加以下脚本，与玩家碰撞后设为不可见，并发布金币减少的消息。 123456789101112public class CoinCollide : MonoBehaviour&#123; void OnTriggerEnter(Collider collider) &#123; //玩家吃到金币事件触发 if (collider.gameObject.name == \"player\") &#123; this.gameObject.SetActive(false); Singleton&lt;GameEventManager&gt;.Instance.RecudeCoinNum(); &#125; &#125;&#125; 玩家与巡逻兵碰撞为巡逻兵添加以下脚本，当巡逻兵与玩家相撞后，设置两者的动作，并发布玩家被捕的消息。 12345678910111213public class PatrolCollide : MonoBehaviour&#123; void OnCollisionStay(Collision other) &#123; //当侦察兵与玩家相撞 if (other.gameObject.name == \"player\") &#123; other.gameObject.GetComponent&lt;Animator&gt;().SetBool(\"death\", true); this.GetComponent&lt;Animator&gt;().SetBool(\"shoot\", true); Singleton&lt;GameEventManager&gt;.Instance.PlayerArrested(); &#125; &#125;&#125; 订阅与发布模式实现发布者发布者类共定义了三种消息类型：分数改变、游戏结束和硬币被玩家拾取。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class GameEventManager : MonoBehaviour&#123; public delegate void ScoreEvent(); public static event ScoreEvent ScoreChange; public delegate void GameOverEvent(); public static event GameOverEvent GameOver; public delegate void CoinEvent(); public static event CoinEvent CoinNumberChange; //玩家逃脱 public void PlayerEscape() &#123; if (ScoreChange != null) &#123; ScoreChange(); &#125; &#125; //玩家被捕 public void PlayerArrested() &#123; if (GameOver != null) &#123; GameOver(); &#125; &#125; public void RecudeCoinNum() &#123; if(CoinNumberChange != null) &#123; CoinNumberChange(); &#125; &#125; public void TimeOut() &#123; if (GameOver != null) &#123; GameOver(); &#125; &#125;&#125; 订阅者订阅者为场景控制器，实现的相关函数如下： 123456789101112131415161718192021222324252627282930void OnEnable()&#123; //注册事件 GameEventManager.ScoreChange += AddScore; GameEventManager.GameOver += GameOver; GameEventManager.CoinNumberChange += ReduceCoinNumber;&#125;void OnDisable()&#123; //取消注册事件 GameEventManager.ScoreChange -= AddScore; GameEventManager.GameOver -= GameOver; GameEventManager.CoinNumberChange -= ReduceCoinNumber;&#125;void AddScore()&#123; scoreRecorder.AddScore();&#125;void GameOver()&#123; gameOver = true; actionManager.DestroyAll();&#125;void ReduceCoinNumber()&#123; coinNumberGet += 1;&#125; 附加功能金币金币是玩家获得游戏胜利的条件，需要拾起地上所有的金币才能结束游戏。 金币工厂金币也通过工厂模式生成，按照预定位置生成固定数量的金币。玩家每次与金币发生碰撞就把金币设为不可见即可，同时在重新开始游戏时全部设置成可见，这样金币就得到了复用，不需要重新生成新的。 1234567891011121314151617181920212223242526272829public class CoinFactory : MonoBehaviour&#123; private GameObject coinPrefab = null; private Vector3[] position = new Vector3[6]; //记录金币的位置 private List&lt;GameObject&gt; coins = new List&lt;GameObject&gt;(); public List&lt;GameObject&gt; GetCoins() &#123; int[] pos_x = &#123;-15, 3, 13, -7, 9&#125;; int[] pos_z = &#123;-15, -3, -15, 15, 10&#125;; for (int i = 0; i &lt; 5; i++) &#123; position[i] = new Vector3(pos_x[i], 1, pos_z[i]); coinPrefab = Object.Instantiate(Resources.Load&lt;GameObject&gt;(\"Prefabs/Coin\"), position[i], Quaternion.identity); coinPrefab.name = \"coin\" + i; coins.Add(coinPrefab); &#125; return coins; &#125; public void Reset() &#123; for (int i = 0; i &lt; coins.Count; i++) &#123; coins[i].SetActive(true); &#125; &#125;&#125; 倒计时为了增加游戏的趣味性，增加了倒计时功能，由TimeManager类实现。当倒计时为0后，游戏结束。 123456789101112131415161718192021222324252627282930313233343536373839404142public class TimeManager : MonoBehaviour&#123; private float gameTime = 90f; private float timer = 0; private string timeCounter; // Use this for initialization void Start() &#123; &#125; public void Reset() &#123; gameTime = 90f; &#125; public string GetTimeText() &#123; return timeCounter; &#125; // Update is called once per frame void Update() &#123; int M = (int)(gameTime / 60); float S = gameTime % 60; timer += Time.deltaTime; if (timer &gt;= 1f) &#123; timer = 0; gameTime--; timeCounter = M.ToString() + \":\" + string.Format(\"&#123;0:00&#125;\", S); &#125; if (gameTime == 0) &#123; Singleton&lt;GameEventManager&gt;.Instance.TimeOut(); &#125; &#125;&#125; 相机跟随相机跟随的实现方式就是让相机在上空与玩家始终保持固定距离，产生相机跟随着玩家移动的效果，增强游戏的真实感。 123456789101112131415161718192021using System.Collections;using System.Collections.Generic;using UnityEngine;public class CameraFollow : MonoBehaviour&#123; public GameObject player; public float smothing = 5f; Vector3 offset; void Start() &#123; offset = new Vector3(0, 25, -20); &#125; void FixedUpdate() &#123; Vector3 target = player.transform.position + offset; transform.position = Vector3.Lerp(transform.position, target, smothing * Time.deltaTime); &#125;&#125; 实现结果游戏画面如下：","categories":[{"name":"3D游戏编程","slug":"3D游戏编程","permalink":"http://yoursite.com/categories/3D游戏编程/"}],"tags":[{"name":"课程作业","slug":"课程作业","permalink":"http://yoursite.com/tags/课程作业/"},{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"}]},{"title":"3D-Game-Programming-Design - 物理系统与碰撞","slug":"3D-Game-Programming-Design-物理系统与碰撞","date":"2019-10-17T01:26:06.000Z","updated":"2020-02-18T14:33:07.443Z","comments":true,"path":"2019/10/17/3D-Game-Programming-Design-物理系统与碰撞/","link":"","permalink":"http://yoursite.com/2019/10/17/3D-Game-Programming-Design-物理系统与碰撞/","excerpt":"3D游戏编程课程的第六次作业： 改进上一次的飞碟（Hit UFO）游戏 按 adapter模式 设计图修改飞碟游戏 使它同时支持物理运动与运动学（变换）运动 课程主页","text":"3D游戏编程课程的第六次作业： 改进上一次的飞碟（Hit UFO）游戏 按 adapter模式 设计图修改飞碟游戏 使它同时支持物理运动与运动学（变换）运动 课程主页 飞碟游戏改进项目地址 演示视频 设计图分析根据题目要求，我们先来看看老师在课件中给出的adapter模式设计图： 分析上述UML图，可以发现：我们要实现的目标就是增加一个PhysisActionManager，并设计一个统一的抽象接口，使得新的动作管理器和之前的CCActionManager都实现它。这样一来，我们就可以选择其中的一个了。 适配器模式简介 意图：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 主要解决：主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。 何时使用： 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。） 如何解决：继承或依赖（推荐）。 关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。 适配器模式通常由两种实现方式：类适配器模式和对象适配器模式，区别就在于前者通过继承实现，后者通过委托（delegate）实现。具体在这里就不展开赘述了，具体可以见这个网站，就老师给出的UML图而言，我们使用的是类适配器，即通过继承方式实现，但似乎老师的UML图给出的不太符合真正的适配器模式，只是抽象出了一个接口而已，不过按照老师的设计图做就可以了。 实现流程新增接口IActionManager1234public interface IActionManager&#123; void playDisk(GameObject disk, float angle, float power, bool isPhysis);&#125; 该接口是场景控制器和动作管理器的桥梁，负责与场景控制器进行交流，从而隐藏了具体动作管理器的实现细节。 适配器ActionManagerAdapterActionManagerAdapter类实现上述接口，实现对于不同运动管理器的管理和调用。 1234567891011121314151617181920212223public class ActionManagerAdapter : MonoBehaviour, IActionManager&#123; public CCActionManager CCAction; public PhysisActionManager PhysisAction; public void playDisk(GameObject disk, float angle, float power, bool isPhysis) &#123; if (!isPhysis) &#123; CCAction.playDisk(disk, angle, power); &#125; else &#123; PhysisAction.playDisk(disk, angle, power); &#125; &#125; void Start() &#123; CCAction = gameObject.AddComponent&lt;CCActionManager&gt;() as CCActionManager; PhysisAction = gameObject.AddComponent&lt;PhysisActionManager&gt;() as PhysisActionManager; &#125;&#125; PhysisAction和PhysisActionManager物理运动的具体实现。实现方法可以参考之前的运动学管理器CCActionManager。不同的地方在于，物理运动是通过对物体添加重力和一个初速度后（使用Rigidbody刚体组件实现），物体就会自动按照物理学规律运动，无需进行额外的管理。 需要注意的是，这里我们在使用物理运动管理器时，设置gameObject.GetComponent&lt;Rigidbody&gt;().useGravity = true;，并添加了初速度。那么，如果需要做到随意切换，那么在运动学管理器中，我们需要做相反的操作，即取消重力和Rigidbody组件的初速度。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class PhysisFlyAction : SSAction&#123; private Vector3 startVector; public float power; public static PhysisFlyAction GetSSAction(Vector3 direction, float angle, float power) &#123; PhysisFlyAction action = CreateInstance&lt;PhysisFlyAction&gt;(); if (direction.x == -1) &#123; action.startVector = Quaternion.Euler(new Vector3(0, 1, -angle)) * Vector3.left * power; &#125; else &#123; action.startVector = Quaternion.Euler(new Vector3(0, 1, angle)) * Vector3.right * power; &#125; action.power = power; return action; &#125; public override void Start() &#123; gameObject.GetComponent&lt;Rigidbody&gt;().velocity = power / 15 * startVector; gameObject.GetComponent&lt;Rigidbody&gt;().useGravity = true; &#125; public override void Update() &#123; if (this.transform.position.y &lt; -10) &#123; this.destory = true; this.callback.SSActionEvent(this); &#125; &#125;&#125;public class PhysisActionManager : SSActionManager, ISSActionCallback&#123; public PhysisFlyAction fly; protected new void Start()&#123; &#125; //飞碟飞行 public void playDisk(GameObject disk, float angle, float power) &#123; fly = PhysisFlyAction.GetSSAction(disk.GetComponent&lt;DiskData&gt;().direction, angle, power); this.RunAction(disk, fly, this); &#125; #region ISSActionCallback implementation public void SSActionEvent(SSAction source, SSActionEventType events = SSActionEventType.Compeleted, int intParam = 0, string strParam = null, Object objectParam = null) &#123; //回调函数,动作执行完后调用 &#125; #endregion&#125; 修改场景控制器对于场景控制器，做以下一些修改： 12345678//添加一个公共的BOOL属性，用于在游戏进行过程中随时切换运动管理器public bool isPhysis = false;//将场景的运动管理器由原先的 CCActionManager 改为 IActionManageractionManager = gameObject.AddComponent&lt;ActionManagerAdapter&gt;() as IActionManager;//为原先的函数调用增加一个参数actionManager.playDisk(disk, angle, power, isPhysis); 修改飞碟Prefab在完成了上述代码后，由于物理运动的实现通过Rigidbody刚体组件，我们需要给飞碟预制添加Rigidbody组件，并不勾选Use Gravity，交给我们的代码控制。 完成上述改动后，就基本上实现了使用 Adapter 模式实现两种运动的要求。 实现结果启动游戏后，我们可以通过右边面板中场景管理器的isPhysis属性在游戏中随时切换不同的运动管理器。 游戏界面如下：","categories":[{"name":"3D游戏编程","slug":"3D游戏编程","permalink":"http://yoursite.com/categories/3D游戏编程/"}],"tags":[{"name":"课程作业","slug":"课程作业","permalink":"http://yoursite.com/tags/课程作业/"},{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"}]},{"title":"浅谈PoW（Proof of Work）共识机制","slug":"浅谈PoW（Proof-of-Work）共识机制","date":"2019-10-15T12:04:55.000Z","updated":"2020-02-18T14:31:13.072Z","comments":true,"path":"2019/10/15/浅谈PoW（Proof-of-Work）共识机制/","link":"","permalink":"http://yoursite.com/2019/10/15/浅谈PoW（Proof-of-Work）共识机制/","excerpt":"阅读材料： Majority_Is_Not_Enough：Bitcoin_Mining_Is_Vulnerable “Proof-of-Work”_Proves_Not_to_Work_version_0.2 定义及起源 工作量证明，PoW（Proof of Work），是一种应对服务与资源滥用、或是阻断服务攻击的经济对策。一般要求用户进行一些耗时适当的复杂运算，并且其答案能被服务方快速验算。以耗用的时间、设备与能源作为担保成本，确保服务与资源是被真正的需求所使用。 工作量证明，从名字不难理解，简单来说就是通过一定的方式或手段来证明在过去一段时间内完成的工作量，以获得别人的奖励和认同。结合我们日常生活，倘若要求 A 监测 B 工作的完整过程，这将极为费时费力且十分低效。因此，我们一般都会采用工作量证明的机制，例如我们的考试成绩、各种证书等等，将重点放在工作的结果上，使得验证工作变得高效。","text":"阅读材料： Majority_Is_Not_Enough：Bitcoin_Mining_Is_Vulnerable “Proof-of-Work”_Proves_Not_to_Work_version_0.2 定义及起源 工作量证明，PoW（Proof of Work），是一种应对服务与资源滥用、或是阻断服务攻击的经济对策。一般要求用户进行一些耗时适当的复杂运算，并且其答案能被服务方快速验算。以耗用的时间、设备与能源作为担保成本，确保服务与资源是被真正的需求所使用。 工作量证明，从名字不难理解，简单来说就是通过一定的方式或手段来证明在过去一段时间内完成的工作量，以获得别人的奖励和认同。结合我们日常生活，倘若要求 A 监测 B 工作的完整过程，这将极为费时费力且十分低效。因此，我们一般都会采用工作量证明的机制，例如我们的考试成绩、各种证书等等，将重点放在工作的结果上，使得验证工作变得高效。 从第二篇文章中得知，第一个被广泛了解和接受的PoW系统是HashCash，并且最开始是用来解决垃圾邮件问题的。这个系统要求发送者去解决一个数学难题：通过在邮件信息中包含一段邮件签名，签名包括收件人地址，时间戳和一个特殊的值“nonce”，使得其哈希值前恰好有一定数量的0。由于哈希算法的不确定性，产生正确的“nonce”的代价十分昂贵，但验证起来却十分简单。当时的人们希望通过这种方法来要求邮件的发送者证明其发送的邮件不是垃圾邮件，同时提高垃圾邮件发送者发送垃圾邮件的代价。但在第二篇文章中提到，PoW对于垃圾邮件问题的解决并没有想象中的有效，存在的问题会在后面讲到。 因此，PoW早在比特币出现之前就已经发明并经过实践检验，证明了其有效性。中本聪在设计区块链的共识机制的时候就采用了PoW。下面我们先来介绍PoW共识机制的原理。 原理由于区块链被设计为一个去中心化的分布式全球账本，那么那以避免的会出现拜占庭将军问题（The Byzantine Generals Problem）。那么，如何使得区块链中的所有分布式节点能够排除错误，快速达成一致，使得比特币系统有效、稳定、正确的运行，就需要一个共识机制，即上文介绍的PoW。 比特币中各个节点通过PoW共识机制争取记账权，并达成一致的流程大致如下： 每当新交易产生，会向全网广播，收到广播的节点们将交易纳入自己的区块中 每个节点（矿工）通过挖矿—解决一个哈希难题，争取获得对于记录了过去一段时间交易信息的区块的记账权 某个节点成功挖到了矿后，向全网广播，由其他节点进行验证 验证区块的有效性后，节点之间达成共识，接受该区块。该节点获得对于这块区块的记账权，负责将其链入区块链的尾部，同时获得比特币奖励 （如果有两个矿工同时挖出矿，区块链就会暂时分叉，但到最后节点总是认可最长的链） PoW共识机制需要满足以下一些条件： 工作量证明函数。该函数找到解很难，但是验证解很容易，保证生成证明需要经过一定数量和难度的计算，以达到耗费一定时间的目的，且难以伪造。 难度值。比特币的工作量证明函数的难度值是动态变化的，难度值的强弱要满足大约在10分钟左右出一块的要求，如果出快速度过快，就会提高难度，反之亦然。 基于以上分析，我们不难得知，基于PoW的共识机制是一种类似于按劳分配的机制，只不过这里的劳动是计算机的算力：算力越大，解决哈希难题的可能性也越大，得到的收益也越大。这就会导致一些问题，出现一些自私的挖矿者，第一篇文章中提到了这一情况，提出了比特币的挖矿协议不是incentive-compatible的，并提出了对于比特币协议进行修改的一些方案。 文章解读在这里对于阅读资料中提到的两篇文章做一个概括和总结： 一、Majority Is Not Enough：Bitcoin Mining Is Vulnerable在这篇文章中，作者提出了一个与传统相反的观点：比特币的共识机制是脆弱的。传统观点认为，PoW共识机制可以有效的抵御少数群体串通合作的情况，但作者描述了一个策略，会使得少数群体获得比该群体公平份额更多的收入，背后的思想是：私自挖矿，就是一个矿池保持其挖出的矿的私有，故意使得区块链分叉。下面做一个简单的介绍： 自私的矿工获利的方式是使得诚实的矿工浪费其努力。我简单概括一下文中提出的场景：假设私有的矿工们率先挖出了一个矿，他们不会马上公开广播，而是秘密创建私有分支，此时他们就处于有利地位，因为他们掌握的链比公开的链更长。后续的，假设自私矿池又发现一个矿，就会继续增长其私有链。 由于私有矿池的算力毕竟占少数，因此他们的优势最终会被抹平，但就在即将抹平的时候，他们会通过一些虚假的矿工（这些矿工受其控制），让他们的广播信息在全网传播的更快，那么，由于比特币协议规定节点都接受并传播最长且最先接收的链，他们的链就会被接受。结果就是，自私的矿工获得全部收益，而诚实矿工们之前的计算都白费了。 当然，文章中提出了一些解决方法，例如节点接收到相同长度的链时，应该传播所有分支，并随机选择一条进行开采等。 二、“Proof-of-Work” Proves Not to Work在第二篇文章中，文章的作者从两个方面：经济方面和安全方面进行了细致的分析，并依据真实的数据进行了预估，得出了一个结论：让每一封电子邮件都附带工作证明是不可行的。论证如下： 从经济角度，如果要使得垃圾邮件发送者由于收益原因不再发送邮件，我们就必须限制其发送垃圾邮件的速度。经过一系列的数据论证，作者得出的结论是，要想达到这样的结果，工作证明的时间最低为43.2秒，但这就会影响合法发送者的发送体验。 从安全角度，由于工作证明的存在，垃圾邮件发送者会想办法提高发送速度，他们就会使用病毒去控制其他机器，让其他邮件为其计算工作证明的结果而不被发现，那么我们就需要把难题难度进一步提高。 因此，部署通用的PoW方案简单但却不合理。文章还提出了，可能存在的可行方案是创建一些白名单，使工作证明只是整体系统的一部分，但这种方案是复杂且脆弱的。 优缺点基于上文，我们已经对于PoW有了一个大致的了解。总体而言，PoW有以下优缺点。 优点 完全去中心化，有效的解决了拜占庭将军问题； 任何人都可以自由接入节点或者离开节点。 缺点 资源浪费。由于计算机算力一定程度上决定了挖到矿的概率，挖矿者会想方设法提高自己矿机的算力，而随着矿机性能的提高，哈希难题的难度也会相应增加。就这样，矿工之间就会展开一场没有硝烟的战争。而这些计算机的算力以及电力资源，由于都是用于产生毫无意义的哈希值，都被浪费掉了； 51%问题。PoW共识机制设计的最大问题就是如果某个团体拥有整个系统51%的算力，他将可以随意篡改区块链。虽然现在对于比特币网络看似目前不太可能，但这也是潜在问题之一，不能保证一定不会发生，目前排名前五的矿池拥有近70%的总哈希算力。一些小型的基于工作证明PoW的网络就更加危险，比如，2016年Ethereum network就收到了攻击威胁； 随着全网算力提升，分叉—即同时挖到矿的概率越来越高，而分叉意味着矿工需要长时间的等待才能确认自己挖出来的区块得到了全网的认可，而用户也需要长时间的等待才能得到交易的确认。 可能的解决方法下面谈一谈我自己了解到和能想到的，对于一些问题的解决思路。 对于算力浪费的问题，我们应该可以设计一种比较有意义的难题，作为PoW共识机制下节点要去解决的对象，例如对于复杂数学难题的求解，舍弃原来毫无意义的哈希值寻找。但这种问题设计起来确实十分困难，很难找到一个像寻找哈希值这样契合PoW要求的难题； 对于矿池越来越庞大的现象，可能需要设计一些奖励和惩罚措施，比如降低大矿池的收入，增加个体矿工的收入，以鼓励矿工们脱离矿池。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://yoursite.com/categories/区块链/"}],"tags":[{"name":"PoW共识机制","slug":"PoW共识机制","permalink":"http://yoursite.com/tags/PoW共识机制/"},{"name":"区块链","slug":"区块链","permalink":"http://yoursite.com/tags/区块链/"}]},{"title":"3D-Game-Programming-Design-与游戏世界交互","slug":"3D-Game-Programming-Design-与游戏世界交互","date":"2019-10-06T15:23:45.000Z","updated":"2020-02-18T14:33:37.750Z","comments":true,"path":"2019/10/06/3D-Game-Programming-Design-与游戏世界交互/","link":"","permalink":"http://yoursite.com/2019/10/06/3D-Game-Programming-Design-与游戏世界交互/","excerpt":"3D游戏编程的第五次作业： 简单的鼠标打飞碟（Hit UFO）游戏 课程主页","text":"3D游戏编程的第五次作业： 简单的鼠标打飞碟（Hit UFO）游戏 课程主页 鼠标打飞碟游戏游戏要求 游戏内容要求： 游戏有 n 个 round，每个 round 都包括10 次 trial； 每个 trial 的飞碟的色彩、大小、发射位置、速度、角度、同时出现的个数都可能不同。它们由该 round 的 ruler 控制； 每个 trial 的飞碟有随机性，总体难度随 round 上升； 鼠标点中得分，得分规则按色彩、大小、速度不同计算，规则可自由设定 游戏要求： 使用带缓存的工厂模式管理不同飞碟的生产与回收，该工厂必须是场景单实例的！具体实现见参考资源 Singleton 模板类 尽可能使用 MVC 结构实现人机交互与游戏模型分离 游戏实现项目地址 演示视频地址 游戏实现了： 共3个Round，每回合10次Trial； 每次Trial中飞碟的颜色、大小、位置，个数等随Round的提升而改变，随机产生但总体难度呈上升趋势；Round 1固定每次只有一个飞碟，后续Round会有几率增加，考虑到同时出现太多点不过来的情况，没有设计同时出现三个以上的情况。 不同颜色飞碟的击中得分不同，游戏会记录玩家历次游戏的最高得分； 玩家共有10次MISS的机会，超过十次则游戏失败。 游戏设计模式沿用之前的MVC模式，并按照要求使用工厂模式生产飞碟。 3个Round，每回合10次Trial，每次Trial中飞碟的颜色、大小、位置等随Round的提升而改变，总体难度呈上升趋势，不同颜色飞碟不同。 实现过程分析在本次的游戏设计要求中，对于之前的游戏设计思路又进行了扩展，新增加了工厂模式。具体要求是使用带缓存的工厂模式管理不同飞碟的生产与回收，且工厂必须是场景单实例的。 飞碟工厂用于单独管理预制飞碟的创建和回收，而不再像之前一样由场景控制器管理，使得代码进一步解耦。以下是飞碟工厂的UML图： 下面介绍一些主要的类，一些基类和接口和之前相同，在这里就不再重复展示了。 飞碟数据类DiskData123456789101112131415using System.Collections;using System.Collections.Generic;using UnityEngine;public class DiskData : MonoBehaviour&#123; //射击此飞碟得分 public int score = 1; //颜色 public Color color = Color.red; //速度 public float speed = 20; //方向 public Vector3 direction;&#125; 飞碟工厂类DiskFactory带缓存的单实例飞碟工厂主要实现了对于飞碟的创建、管理和回收。他的使用有以下好处： 包装了复杂的Disk生产与回收逻辑，易于使用； 带缓存的工厂来避免频繁的创建与销毁操作，提高效率：通过两个List实现； 包含了Disk产生规则（控制每个round的难度），可以积极应对未来游戏规则的变化，减少维护成本。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139public class DiskFactory : MonoBehaviour&#123; public GameObject diskPrefab = null; private List&lt;DiskData&gt; used = new List&lt;DiskData&gt;(); private List&lt;DiskData&gt; free = new List&lt;DiskData&gt;(); public GameObject GetDisk(int round) &#123; if (free.Count &gt; 0) &#123; diskPrefab = free[0].gameObject; free.Remove(free[0]); &#125; else &#123; diskPrefab = Instantiate&lt;GameObject&gt;(Resources.Load&lt;GameObject&gt;(\"Prefabs/disk\"), Vector3.zero, Quaternion.identity); diskPrefab.AddComponent&lt;DiskData&gt;(); &#125; int start = 0, end = 0, diskType = 0; if(round == 1) &#123; start = 0; end = 300; &#125; if (round == 2) &#123; start = 200; end = 400; &#125; else if (round == 3) &#123; start = 300; end = 500; &#125; int temp = Random.Range(start, end); if (temp &gt; 400) &#123; diskType = 5; &#125; else if (temp &gt; 300) &#123; diskType = 4; &#125; else if (temp &gt; 200) &#123; diskType = 3; &#125; else if (temp &gt; 100) &#123; diskType = 2; &#125; else &#123; diskType = 1; &#125; //生成不同的飞碟 switch (diskType) &#123; case 1: &#123; diskPrefab.GetComponent&lt;DiskData&gt;().color = Color.white; diskPrefab.GetComponent&lt;DiskData&gt;().speed = 4.0f; float RanX = UnityEngine.Random.Range(-1f, 1f) &lt; 0 ? -1 : 1; diskPrefab.GetComponent&lt;DiskData&gt;().direction = new Vector3(RanX, 1, 0); diskPrefab.GetComponent&lt;Renderer&gt;().material.color = Color.white; diskPrefab.GetComponent&lt;DiskData&gt;().score = 1; diskPrefab.transform.localScale = new Vector3(2f, 0.2f, 2f); break; &#125; case 2: &#123; diskPrefab.GetComponent&lt;DiskData&gt;().color = Color.green; diskPrefab.GetComponent&lt;DiskData&gt;().speed = 6.0f; float RanX = UnityEngine.Random.Range(-1f, 1f) &lt; 0 ? -1 : 1; diskPrefab.GetComponent&lt;DiskData&gt;().direction = new Vector3(RanX, 1, 0); diskPrefab.GetComponent&lt;Renderer&gt;().material.color = Color.green; diskPrefab.GetComponent&lt;DiskData&gt;().score = 2; diskPrefab.transform.localScale = new Vector3(1.6f, 0.16f, 1.6f); break; &#125; case 3: &#123; diskPrefab.GetComponent&lt;DiskData&gt;().color = Color.blue; diskPrefab.GetComponent&lt;DiskData&gt;().speed = 8.0f; float RanX = UnityEngine.Random.Range(-1f, 1f) &lt; 0 ? -1 : 1; diskPrefab.GetComponent&lt;DiskData&gt;().direction = new Vector3(RanX, 1, 0); diskPrefab.GetComponent&lt;Renderer&gt;().material.color = Color.blue; diskPrefab.GetComponent&lt;DiskData&gt;().score = 3; diskPrefab.transform.localScale = new Vector3(1.4f, 0.14f, 1.4f); break; &#125; case 4: &#123; diskPrefab.GetComponent&lt;DiskData&gt;().color = Color.red; diskPrefab.GetComponent&lt;DiskData&gt;().speed = 6.0f; float RanX = UnityEngine.Random.Range(-1f, 1f) &lt; 0 ? -1 : 1; diskPrefab.GetComponent&lt;DiskData&gt;().direction = new Vector3(RanX, 1, 0); diskPrefab.GetComponent&lt;Renderer&gt;().material.color = Color.red; diskPrefab.GetComponent&lt;DiskData&gt;().score = 4; diskPrefab.transform.localScale = new Vector3(1.0f, 0.1f, 1.0f); break; &#125; case 5: &#123; diskPrefab.GetComponent&lt;DiskData&gt;().color = Color.black; diskPrefab.GetComponent&lt;DiskData&gt;().speed = 8.0f; float RanX = UnityEngine.Random.Range(-1f, 1f) &lt; 0 ? -1 : 1; diskPrefab.GetComponent&lt;DiskData&gt;().direction = new Vector3(RanX, 1, 0); diskPrefab.GetComponent&lt;Renderer&gt;().material.color = Color.black; diskPrefab.GetComponent&lt;DiskData&gt;().score = 5; diskPrefab.transform.localScale = new Vector3(0.8f, 0.08f ,0.8f); break; &#125; default:break; &#125; used.Add(diskPrefab.GetComponent&lt;DiskData&gt;()); diskPrefab.SetActive(false); return diskPrefab; &#125; public void FreeDisk(GameObject disk) &#123; foreach (DiskData dd in used) &#123; if(disk.GetInstanceID() == dd.gameObject.GetInstanceID()) &#123; dd.gameObject.SetActive(false); used.Remove(dd); free.Add(dd); break; &#125; &#125; &#125;&#125; 场景控制器 RoundController场景控制器统筹管理各个组件，管理游戏的整体进程。LoadResource函数会将当前的回合情况传递给飞碟工厂，以产生相应难度的飞碟。Update函数每隔一段时间触发一次Trial，即发送飞碟，同时判断是否继续还是结束游戏，并对当前未被击中的飞碟进行回收。此外，还负责处理用户射击事件，判断是否击中并执行后续的行为，如用户扣血，或者分数增加。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202public class RoundController : MonoBehaviour, ISceneController, IUserAction&#123; public DiskFactory diskFactory; public CCActionManager actionManager; public ScoreRecorder scoreRecorder; public UserGUI userGui; private Queue&lt;GameObject&gt; diskQueue = new Queue&lt;GameObject&gt;(); private List&lt;GameObject&gt; diskMissed = new List&lt;GameObject&gt;(); private int totalRound = 3; private int trialNumPerRound = 10; private int currentRound = -1; private int currentTrial = -1; private float throwSpeed = 2f; private int gameState = 0; //-1：失败 0：初始状态 1：进行中 2：胜利 private float throwInterval = 0; private int userBlood = 10; void Awake() &#123; SSDirector director = SSDirector.GetInstance(); director.CurrentSceneController = this; diskFactory = Singleton&lt;DiskFactory&gt;.Instance; userGui = gameObject.AddComponent&lt;UserGUI&gt;() as UserGUI; actionManager = gameObject.AddComponent&lt;CCActionManager&gt;() as CCActionManager; scoreRecorder = new ScoreRecorder(); &#125; public void LoadResource() &#123; diskQueue.Enqueue(diskFactory.GetDisk(currentRound)); &#125; public void ThrowDisk(int count) &#123; while(diskQueue.Count &lt;= count) &#123; LoadResource(); &#125; for(int i = 0; i &lt; count; i++) &#123; float position_x = 16; GameObject disk = diskQueue.Dequeue(); diskMissed.Add(disk); disk.SetActive(true); //设置飞碟位置 float ran_y = Random.Range(-3f, 3f); float ran_x = Random.Range(-1f, 1f) &lt; 0 ? -1 : 1; disk.GetComponent&lt;DiskData&gt;().direction = new Vector3(ran_x, ran_y, 0); Vector3 position = new Vector3(-disk.GetComponent&lt;DiskData&gt;().direction.x * position_x, ran_y, 0); disk.transform.position = position; //设置飞碟初始所受的力和角度 float power = Random.Range(10f, 15f); float angle = Random.Range(15f, 28f); actionManager.diskFly(disk, angle, power); &#125; &#125; void levelUp() &#123; currentRound += 1; throwSpeed -= 0.5f; currentTrial = 1; &#125; void Update() &#123; if(gameState == 1) &#123; if(userBlood &lt;= 0 || (currentRound == totalRound &amp;&amp; currentTrial == trialNumPerRound)) &#123; GameOver(); return; &#125; else &#123; if (currentTrial &gt; trialNumPerRound) &#123; levelUp(); &#125; if (throwInterval &gt; throwSpeed) &#123; int throwCount = generateCount(currentRound); ThrowDisk(throwCount); throwInterval = 0; currentTrial += 1; &#125; else &#123; throwInterval += Time.deltaTime; &#125; &#125; &#125; for (int i = 0; i &lt; diskMissed.Count; i++) &#123; GameObject temp = diskMissed[i]; //飞碟飞出摄像机视野且未被打中 if (temp.transform.position.y &lt; -8 &amp;&amp; temp.gameObject.activeSelf == true) &#123; diskFactory.FreeDisk(diskMissed[i]); diskMissed.Remove(diskMissed[i]); userBlood -= 1; &#125; &#125; &#125; public int generateCount(int currentRound) &#123; if(currentRound == 1) &#123; return 1; &#125; else if(currentRound == 2) &#123; return Random.Range(1, 2); &#125; else &#123; return Random.Range(1, 3); &#125; &#125; public void StartGame() &#123; gameState = 1; currentRound = 1; currentTrial = 1; userBlood = 10; throwSpeed = 2f; throwInterval = 0;&#125; public void GameOver() &#123; if(userBlood &lt;= 0) &#123; gameState = -1;//失败 &#125; else &#123; gameState = 2;//胜利 &#125; &#125; public void Restart() &#123; scoreRecorder.Reset(); StartGame(); &#125; public void Hit(Vector3 pos) &#123; Ray ray = Camera.main.ScreenPointToRay(pos); RaycastHit[] hits; hits = Physics.RaycastAll(ray); bool notHit = false; foreach (RaycastHit hit in hits) //射线打中物体 if (hit.collider.gameObject.GetComponent&lt;DiskData&gt;() != null) &#123; //射中的物体要在没有打中的飞碟列表中 for (int j = 0; j &lt; diskMissed.Count; j++) &#123; if (hit.collider.gameObject.GetInstanceID() == diskMissed[j].gameObject.GetInstanceID()) &#123; notHit = true; &#125; &#125; if (!notHit) &#123; return; &#125; diskMissed.Remove(hit.collider.gameObject); //记录分数 scoreRecorder.Record(hit.collider.gameObject); diskFactory.FreeDisk(hit.collider.gameObject); break; &#125; &#125; public int GetScore() &#123; return scoreRecorder.GetScore(); &#125; public int GetCurrentRound() &#123; return currentRound; &#125; public int GetBlood() &#123; return userBlood; &#125; public int GetGameState() &#123; return gameState; &#125;&#125; 飞碟动作类CCFlyAction该类负责实现飞碟的飞行效果，并在下降到一定高度后结束该动作。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class CCFlyAction : SSAction&#123; public float gravity = -5; //向下加速度 private Vector3 startVector; //初速度向量 private Vector3 gravityVector = Vector3.zero; //加速度的向量，初始时为0 private float time; //已过去时间 private Vector3 currentAngle = Vector3.zero; //当前时间的欧拉角 public static CCFlyAction GetSSAction(Vector3 direction, float angle, float power) &#123; CCFlyAction action = CreateInstance&lt;CCFlyAction&gt;(); if (direction.x == -1) &#123; action.startVector = Quaternion.Euler(new Vector3(0, 1, -angle)) * Vector3.left * power; &#125; else &#123; action.startVector = Quaternion.Euler(new Vector3(0, 1, angle)) * Vector3.right * power; &#125; return action; &#125; public override void Start() &#123; &#125; public override void Update() &#123; time += Time.fixedDeltaTime; gravityVector.y = gravity * time; transform.position += (startVector + gravityVector) * Time.fixedDeltaTime; currentAngle.z = Mathf.Atan((startVector.y + gravityVector.y) / startVector.x) * Mathf.Rad2Deg; transform.eulerAngles = currentAngle; if (this.transform.position.y &lt; -10) &#123; this.destory = true; this.callback.SSActionEvent(this); &#125; &#125;&#125; 用户交互界面交互界面比较简单，就是简单的根据游戏的进行状态显示不同的信息，如开始前显示开始游戏，进行时显示当前回合、得分、玩家血量，结束后显示重新开始等字样。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class UserGUI : MonoBehaviour&#123; private IUserAction action; private string score, round; int blood, gameState, HighestScore; // Start is called before the first frame update void Start() &#123; action = SSDirector.GetInstance().CurrentSceneController as IUserAction; &#125; // Update is called once per frame void Update() &#123; gameState = action.GetGameState(); &#125; void OnGUI() &#123; GUIStyle text_style; GUIStyle button_style; text_style = new GUIStyle() &#123; fontSize = 20 &#125;; button_style = new GUIStyle(\"button\") &#123; fontSize = 15 &#125;; if (gameState == 0) &#123; //初始界面 if (GUI.Button(new Rect(Screen.width / 2 - 50, 80, 100, 60), \"Start Game\", button_style)) &#123; action.StartGame(); &#125; &#125; else if(gameState == 1) &#123; //游戏进行中 //用户射击 if (Input.GetButtonDown(\"Fire1\")) &#123; Vector3 mousePos = Input.mousePosition; action.Hit(mousePos); &#125; score = \"Score: \" + action.GetScore().ToString(); GUI.Label(new Rect(200, 5, 100, 100), score, text_style); round = \"Round: \" + action.GetCurrentRound().ToString(); GUI.Label(new Rect(400, 5, 100, 100), round, text_style); blood = action.GetBlood(); string bloodStr = \"Blood: \" + blood.ToString(); GUI.Label(new Rect(600, 5, 50, 50), bloodStr, text_style); &#125; else &#123; //游戏结束，有两种情况 if (gameState == 2) &#123; if (action.GetScore() &gt; HighestScore) &#123; HighestScore = action.GetScore(); &#125; GUI.Label(new Rect(Screen.width / 2 - 50, Screen.height / 2 - 250, 100, 60), \"Game Over\", text_style); string record = \"Highest Score: \" + HighestScore.ToString(); GUI.Label(new Rect(Screen.width / 2 - 70, Screen.height / 2 - 150, 150, 60), record, text_style); &#125; else &#123; GUI.Label(new Rect(Screen.width / 2 - 50, Screen.height / 2 - 150, 100, 70), \"You Lost!\", text_style); &#125; if (GUI.Button(new Rect(Screen.width / 2 - 50, Screen.height / 2 - 30, 100, 60), \"Restart\", button_style)) &#123; action.Restart(); &#125; &#125; &#125; &#125; 游戏截图 改进空间 飞碟重用机制的实现比较粗糙。由于我判断工厂是否需要回收飞碟的方式是：飞碟落回到一定高度下后就回收。这就导致了由于飞碟速度的不同，有时候飞碟回落过慢，导致还未回收，就又需要另外一个飞碟，就会多创建一些新的飞碟出来。 用户界面比较粗糙，不够精美。 用户射中飞碟后可以添加一些爆炸效果。","categories":[{"name":"3D游戏编程","slug":"3D游戏编程","permalink":"http://yoursite.com/categories/3D游戏编程/"}],"tags":[{"name":"课程作业","slug":"课程作业","permalink":"http://yoursite.com/tags/课程作业/"},{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"}]},{"title":"3D-Game-Programming-Design-游戏对象与图形基础","slug":"3D-Game-Programming-Design-游戏对象与图形基础","date":"2019-09-22T02:38:02.000Z","updated":"2020-02-18T14:33:16.899Z","comments":true,"path":"2019/09/22/3D-Game-Programming-Design-游戏对象与图形基础/","link":"","permalink":"http://yoursite.com/2019/09/22/3D-Game-Programming-Design-游戏对象与图形基础/","excerpt":"3D游戏编程的第四次作业： 牧师与恶魔 - 动作分离版 课程主页","text":"3D游戏编程的第四次作业： 牧师与恶魔 - 动作分离版 课程主页 基本操作演练 下载 Fantasy Skybox FREE， 构建自己的游戏场景 从Asset Store中搜索并下载Fantasy Skybox FREE后，其中包含了好几个skybox，用于设置游戏界面的背景。同时还有一些树的预制Prefabs，地面图片等等，可以用于制作地形Terrain。但由于这个资源是免费的，个人感觉并不是很好看。 写一个简单的总结，总结游戏对象的使用 目前为止，我对于游戏对象的使用还只是停留在最基本的操作上：移动，缩放，旋转等等，并可以通过编写脚本来对于游戏对象进行加载和控制，来达到一些简单的游戏功能。 此外还因为从Asset Store中下载的模型自带动作，我简单的尝试了对于游戏对象动作的控制，关键在于设定具体的状态，将动作与状态绑定，并设置状态之间的转移。 编程实践 牧师与魔鬼 动作分离版 【2019新要求】：设计一个裁判类，当游戏达到结束条件时，通知场景控制器游戏结束 项目地址 由于只是变更了代码结构，实际游戏效果并没有改变，所以视频沿用上一次的：演示视频地址 在上一次的作业中，对于牧师与魔鬼这个游戏，我们采用了MVC的设计架构，使得程序在一定程度上解耦，每一层可以专注于自己的业务逻辑。但是，在实践中发现，即使对于这样一个简单的小游戏，在控制器层所要做的事情还是太多了，既要负责加载资源，同时要处理模型间很多动作的执行与判断，导致代码比较冗长。 因此，本次作业中我们将写一个动作管理器，负责单独管理动作。除此之外，还将游戏结束判断的代码也提取了出来，写了一个裁判类。 以下是动作管理器的UML类图： 基于上述类，修改游戏的脚本结构如下： 下面简单介绍一些这些类的关系及其职责： SSActionSSAction是所有动作的基类。包含了一些所有动作都会用到的属性。 1234567891011121314151617181920public class SSAction : ScriptableObject&#123; public bool enable = true; public bool destory = false; public GameObject gameObject &#123; get; set; &#125; public Transform transform &#123; get; set; &#125; public ISSActionCallback callback &#123; get; set; &#125; protected SSAction() &#123; &#125; public virtual void Start() &#123; throw new System.NotImplementedException(); &#125; public virtual void Update() &#123; throw new System.NotImplementedException(); &#125;&#125; SSActionCallback类似于回调函数，作为动作和动作管理器交流的一种方式。我们可以看到，在动作基类中，存在ISSActionCallbcak属性，而动作管理器类会继承这个接口，并实现其方法。每当动作管理器执行某个动作时，会把该动作的这个属性设为自己。因此，当动作完成后，就可以通过callback.SSActionEvent这个函数通知管理器。 12345678910public enum SSActionEventType : int &#123; Started, Compeleted &#125;public interface ISSActionCallback&#123; void SSActionEvent(SSAction source, SSActionEventType events = SSActionEventType.Compeleted, int intParam = 0, string strParam = null, Object objectParam = null);&#125; CCMoveToAction简单的移动，从上次作业的代码中提取出的 123456789101112131415161718192021222324252627282930public class CCMoveToAction : SSAction&#123; public Vector3 target; public float speed; public static CCMoveToAction GetSSAction(Vector3 target, float speed) &#123; CCMoveToAction action = ScriptableObject.CreateInstance&lt;CCMoveToAction&gt;(); action.target = target; action.speed = speed; return action; &#125; // Use this for initialization public override void Start() &#123; &#125; // Update is called once per frame public override void Update() &#123; this.transform.position = Vector3.MoveTowards(this.transform.position, target, speed * Time.deltaTime); if(this.transform.position == target) &#123; this.destory = true; this.callback.SSActionEvent(this); &#125; &#125;&#125; CCSequenceAction这个类用于实现一系列连续的动作，通过List保存所要执行的一系列动作，采用了门面设计模式，将连续的动作封装。因此，它有着动作管理器的效果，所以也实现了ISSActionCallback接口。当一系列动作完成后，先通知这个类，然后这个类通知更高一级的管理器。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class CCSequenceAction : SSAction, ISSActionCallback&#123; public List&lt;SSAction&gt; sequence; public int repeat = -1; public int currentIndex = 0; public static CCSequenceAction GetSSAction(int repeat, int currentIndex, List&lt;SSAction&gt; sequence) &#123; CCSequenceAction action = ScriptableObject.CreateInstance&lt;CCSequenceAction&gt;(); action.repeat = repeat; action.currentIndex = currentIndex; action.sequence = sequence; return action; &#125; // 执行动作前，为每个动作注入当前动作游戏对象，并将自己作为动作事件的接收者 public override void Start() &#123; foreach(SSAction action in sequence) &#123; action.gameObject = this.gameObject; action.transform = this.transform; action.callback = this; action.Start(); &#125; &#125; // Update is called once per frame public override void Update() &#123; if (sequence.Count == 0) return; if(currentIndex &lt; sequence.Count) &#123; sequence[currentIndex].Update(); &#125; &#125; public void SSActionEvent(SSAction source, SSActionEventType events = SSActionEventType.Compeleted, int intParam = 0, string strParam = null, Object objectParam = null) &#123; source.destory = false; this.currentIndex++; if(this.currentIndex &gt;= sequence.Count) &#123; this.currentIndex = 0; if (repeat &gt; 0) repeat--; if(repeat == 0) &#123; this.destory = true; this.callback.SSActionEvent(this); &#125; &#125; &#125; private void OnDestroy() &#123; foreach(SSAction action in sequence) &#123; Object.Destroy(action); &#125; &#125;&#125; SSActionManager动作管理器基类，实现了动作管理器的核心功能。在每次Update时，检查所有动作，通过两个队列和一个字典数据结构完成当前所有动作的添加、执行、销毁操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class SSActionManager : MonoBehaviour&#123; private Dictionary&lt;int, SSAction&gt; actions = new Dictionary&lt;int, SSAction&gt;(); private List&lt;SSAction&gt; waitingAdd = new List&lt;SSAction&gt;(); private List&lt;int&gt; waitingDelete = new List&lt;int&gt;(); // Use this for initialization protected void Start() &#123; &#125; // Update is called once per frame protected void Update() &#123; foreach (SSAction ac in waitingAdd) &#123; actions[ac.GetInstanceID()] = ac; &#125; waitingAdd.Clear(); foreach(KeyValuePair&lt;int, SSAction&gt; kv in actions) &#123; SSAction ac = kv.Value; if (ac.destory) &#123; waitingDelete.Add(ac.GetInstanceID()); &#125;else if (ac.enable) &#123; ac.Update(); &#125; &#125; foreach(int key in waitingDelete) &#123; SSAction ac = actions[key]; actions.Remove(key); Object.Destroy(ac); &#125; waitingDelete.Clear(); &#125; public void RunAction(GameObject gameobject, SSAction action, ISSActionCallback manager) &#123; action.gameObject = gameobject; action.transform = gameobject.transform; action.callback = manager; waitingAdd.Add(action); action.Start(); &#125;&#125; CCActionManager具体的动作管理器，其中Update函数沿用父类的，并定义了具体的动作和回调函数。通过父类的RunAction为动作设置对象等信息，并将动作加入等待队列。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class CCActionManager : SSActionManager, ISSActionCallback&#123; public FirstController sceneController; public CCMoveToAction moveBoat; public CCSequenceAction moveRole; //移动角色是一个组合动作 // Use this for initialization protected new void Start() &#123; sceneController = SSDirector.GetInstance().CurrentSceneController as FirstController; sceneController.actionManager = this; &#125; // Update is called once per frame protected new void Update() &#123; base.Update(); &#125; public void MoveBoat(GameObject boat, Vector3 target, float speed) &#123; moveBoat = CCMoveToAction.GetSSAction(target, speed); this.RunAction(boat, moveBoat, this); sceneController.moving = true; &#125; public void MoveRole(GameObject role, Vector3 middlePosition, Vector3 endPosition, float speed) &#123; SSAction step1 = CCMoveToAction.GetSSAction(middlePosition, speed); SSAction step2 = CCMoveToAction.GetSSAction(endPosition, speed); moveRole = CCSequenceAction.GetSSAction(1, 0, new List&lt;SSAction&gt; &#123; step1, step2 &#125;); this.RunAction(role, moveRole, this); sceneController.moving = true; &#125; #region ISSActionCallback implementation public void SSActionEvent(SSAction source, SSActionEventType events = SSActionEventType.Compeleted, int intParam = 0, string strParam = null, Object objectParam = null) &#123; //回调函数,动作执行完后调用 sceneController.moving = false; &#125; #endregion&#125; 以上就是动作管理器的全部类，在完成这些类后，需要对于之前的代码进行修改，最主要的是以下函数，其余细节部分此处不再赘述，具体可以见项目地址。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 public void MoveRole(RoleModel role) &#123; if (!gaming || moving) return; Vector3 endPosition; if (role.IsOnBoat()) //上岸 &#123; //这里，为了和原游戏一致，使牧师和魔鬼在两边的排列顺序一致 role = Boat.DeletePassenger(role); int id = role.GetName()[role.GetName().Length - 1] - '0'; if (role.IsGood()) &#123; endPosition = PrisetsOriginPositions[id]; &#125; else &#123; endPosition = DevilsOriginPositions[id]; &#125; if(role.GetSide() == -1) &#123; endPosition.x = 0 - endPosition.x; &#125; Vector3 middlePosition = new Vector3(role.GetRole().transform.position.x, endPosition.y, endPosition.z); actionManager.MoveRole(role.GetRole(), middlePosition, endPosition, speed); role.GoLand(); &#125; else //上船 &#123; if (Boat.IsFull() || Boat.GetSide() != role.GetSide()) &#123; return; &#125; endPosition = Boat.getEmptyPosition(); Vector3 middlePosition = new Vector3(endPosition.x, role.GetRole().transform.position.y, endPosition.z); actionManager.MoveRole(role.GetRole(), middlePosition, endPosition, speed); role.GoBoat(Boat); Boat.AddPassenger(role); &#125; &#125; public void MoveBoat() &#123; //当船为空，或者船或人物在运动时，不允许移动船 if (Boat.IsEmpty() || moving) return; actionManager.MoveBoat(Boat.GetBoat(), Boat.GetMoveDirection(), speed); &#125;&#125; 可以看到，真正动作的执行代码已经很少，全部交由actionManager完成。 裁判类裁判类比较简单，只是把之前用于判断结果的代码单独写成一个类即可。我采用了让其在每次Update的时候进行判断，似乎频率有点过高，应该有更好的办法，但对于这个小游戏还是没有影响的。以下是裁判类代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class Judger : MonoBehaviour&#123; public FirstController sceneController; // Use this for initialization public void Start() &#123; sceneController = SSDirector.GetInstance().CurrentSceneController as FirstController; &#125; // Update is called once per frame public void Update() &#123; if((sceneController.currentState = Judge()) != 0) &#123; sceneController.gaming = false; &#125; &#125; public int Judge() &#123; if (sceneController.moving) return 0; //计算两边的牧师和恶魔数量 int rightPriestNum = 0, leftPriestNum = 0, rightDevilNum = 0, leftDevilNum = 0; for (int i = 0; i &lt; 3; i++) &#123; if (sceneController.Priests[i].GetSide() == 1) &#123; rightPriestNum++; &#125; else &#123; leftPriestNum++; &#125; if (sceneController.Devils[i].GetSide() == 1) &#123; rightDevilNum++; &#125; else &#123; leftDevilNum++; &#125; &#125; if (leftPriestNum + leftDevilNum == 6) &#123; for (int i = 0; i &lt; 3; i++) &#123; sceneController.Devils[i].Lose(); &#125; return 1; //win &#125; else if ((leftPriestNum &gt; 0 &amp;&amp; leftDevilNum &gt; leftPriestNum) || (rightPriestNum &gt; 0 &amp;&amp; rightDevilNum &gt; rightPriestNum)) &#123; int attackSide; if (leftDevilNum &gt; leftPriestNum) attackSide = -1; else attackSide = 1; for (int i = 0; i &lt; 3; i++) &#123; if (sceneController.Devils[i].GetSide() == attackSide) sceneController.Devils[i].Attack(); &#125; return -1; //lose &#125; else &#123; return 0; &#125; &#125;&#125; 游戏界面游戏界面也与上次相同： 感悟本次的作业，主要是对于上一次作业的代码结构进行了调整，使得各部分代码各司其职，分工合作。但在初看这些类关系的时候，确实让我费了一番功夫才看明白。但也真的学习到了不少，让我对于游戏框架设计有了更加深入的认识，特别是回调函数callback的使用，在一些特定的场景十分有效。 遗憾的是本来想对游戏画面进行进一步完善的，但是近期作业较多，没有抽出时间，希望以后可以有机会。","categories":[{"name":"3D游戏编程","slug":"3D游戏编程","permalink":"http://yoursite.com/categories/3D游戏编程/"}],"tags":[{"name":"课程作业","slug":"课程作业","permalink":"http://yoursite.com/tags/课程作业/"},{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"}]},{"title":"3D Game Programming & Design - 空间与运动","slug":"3D-Game-Programming-Design-空间与运动","date":"2019-09-16T08:48:24.000Z","updated":"2020-02-18T14:32:15.899Z","comments":true,"path":"2019/09/16/3D-Game-Programming-Design-空间与运动/","link":"","permalink":"http://yoursite.com/2019/09/16/3D-Game-Programming-Design-空间与运动/","excerpt":"3D游戏编程的第三次作业： 使用Unity模拟出了太阳系中的行星运动 采用MVC设计模式编写了一个小游戏：牧师与恶魔 课程主页","text":"3D游戏编程的第三次作业： 使用Unity模拟出了太阳系中的行星运动 采用MVC设计模式编写了一个小游戏：牧师与恶魔 课程主页 简答并用程序验证 游戏对象运动的本质是什么？ 游戏对象运动的本质就是使用矩阵变换（平移、旋转、缩放）改变游戏对象的空间属性。 请用三种方法以上方法，实现物体的抛物线运动。 方法一：运动分解。将抛物线运动分解为横向和纵向的运动叠加，直接修改物体的位置 123456789101112131415161718192021222324public class method1 : MonoBehaviour&#123; public float speed = 200F; //初速度 public float angle = 60; //起始方向与地面夹角 private float G = 9.8F; //重力加速度 private float xSpeed; //x方向速度分量 private float ySpeed; //y方向速度分量 // Start is called before the first frame update void Start() &#123; xSpeed = speed * Mathf.Cos(angle / 180 * Mathf.PI); ySpeed = speed * Mathf.Sin(angle / 180 * Mathf.PI); &#125; // Update is called once per frame void Update() &#123; this.transform.position += Vector3.right * Time.deltaTime * xSpeed; this.transform.position += Vector3.up * Time.deltaTime * ySpeed; ySpeed -= G * Time.deltaTime; &#125;&#125; 方法二：使用Transform 的方法 Translate 123456789101112131415161718192021222324public class method2 : MonoBehaviour&#123; public float speed = 200F; //初速度 public float angle = 60; //起始方向与地面夹角 private float G = 9.8F; //重力加速度 private float xSpeed; //x方向速度分量 private float ySpeed; //y方向速度分量 // Start is called before the first frame update void Start() &#123; xSpeed = speed * Mathf.Cos(angle / 180 * Mathf.PI); ySpeed = speed * Mathf.Sin(angle / 180 * Mathf.PI); &#125; // Update is called once per frame void Update() &#123; Vector3 direction = (Vector3.right * xSpeed + Vector3.up * ySpeed) * Time.deltaTime; this.transform.Translate(direction); ySpeed -= G * Time.deltaTime; &#125;&#125; 方法三：使用Vector3 的方法MoveTowards 123456789101112131415161718192021222324public class method3 : MonoBehaviour&#123; public float speed = 200F; //初速度 public float angle = 60; //起始方向与地面夹角 private float G = 9.8F; //重力加速度 private float xSpeed; //x方向速度分量 private float ySpeed; //y方向速度分量 // Start is called before the first frame update void Start() &#123; xSpeed = speed * Mathf.Cos(angle / 180 * Mathf.PI); ySpeed = speed * Mathf.Sin(angle / 180 * Mathf.PI); &#125; // Update is called once per frame void Update() &#123; Vector3 destation= this.transform.position + (Vector3.right * xSpeed + Vector3.up * ySpeed) * Time.deltaTime; this.transform.position = Vector3.MoveTowards(this.transform.position, destation, 1); ySpeed -= G * Time.deltaTime; &#125;&#125; 写一个程序，实现一个完整的太阳系， 其他星球围绕太阳的转速必须不一样，且不在一个法平面上。 项目地址 完整演示视频 以下简述实现过程： 首先创建10个球对象：一个太阳，八个行星，以及一个月亮。八个行星为太阳的子对象，月亮为地球的子对象。 按照真实的太阳系设置各个星球的大小，位置，并用网上收集到的图片更改球的外观。 编写两个脚本，实现公转和自转: 公转： 12345678910111213141516171819202122using System.Collections;using System.Collections.Generic;using UnityEngine;public class RotateAroundOther : MonoBehaviour&#123; public Transform sun; public int speed = 50; float ry,rz; // Start is called before the first frame update void Start() &#123; ry = Random.Range(30, 60); rz = Random.Range(-20, 20); &#125; // Update is called once per frame void Update() &#123; Vector3 axis = new Vector3(0, ry, rz); this.transform.RotateAround(sun.position, axis, speed * Time.deltaTime); &#125;&#125; 自转： 1234567891011121314151617using System.Collections;using System.Collections.Generic;using UnityEngine;public class RotateAroundSelf : MonoBehaviour&#123; // Start is called before the first frame update void Start() &#123; &#125; // Update is called once per frame void Update() &#123; this.transform.RotateAround(this.transform.position, Vector3.up, 1 * Time.deltaTime); &#125;&#125; 将上述公转和自转代码赋给各个星球，设置好公转的转速和中心即可。至于为了使公转的法平面不同而设置的ry = Random.Range(30, 60); rz = Random.Range(-20, 20);，具体数值可以自己调整。到此，太阳系的基本功能就以实现了 此外，我还增加了背景；实现了暂停和开始功能；为行星的运动添加了轨道，使得转动更加直观。 最终效果图： 编程实践要求阅读以下游戏脚本 Priests and Devils Priests and Devils is a puzzle game in which you will help the Priests and Devils to cross the river within the time limit. There are 3 priests and 3 devils at one side of the river. They all want to get to the other side of this river, but there is only one boat and this boat can only carry two persons each time. And there must be one person steering the boat from one side to the other side. In the flash game, you can click on them to move them and click the go button to move the boat to the other direction. If the priests are out numbered by the devils on either side of the river, they get killed and the game is over. You can try it in many &gt; ways. Keep all priests alive! Good luck! 示例地址 程序需要满足的要求： 列出游戏中提及的事物（Objects） 用表格列出玩家动作表（规则表），注意，动作越少越好 请将游戏中对象做成预制 在 GenGameObjects 中创建长方形、正方形、球及其色彩代表游戏中的对象。 使用C#集合类型有效组织对象 整个游戏仅主摄像机和一个 Empty 对象，其他对象必须代码动态生成！！！ 。 整个游戏不许出现 Find 游戏对象， SendMessage 这类突破程序结构的通讯耦合语句。 违背本条准则，不给分 请使用课件架构图编程，不接受非 MVC 结构程序 注意细节，例如：船未靠岸，牧师与魔鬼上下船运动中，均不能接受用户事件！ 游戏中提及的事物 魔鬼 牧师 船 河流 河两岸 玩家动作表（规则表） 条件 动作 结果 船停靠在岸边时 点击与船同侧的人物（牧师/魔鬼） 人物跳进船或跳回岸边 船停靠在岸边且船上有人时 点击GO按钮 船驶向对岸 游戏胜利或失败后 点击Restart按钮 重新开始游戏 游戏分析与前期准备 按照题中要求，游戏的设计采用MVC（Model - View - Controller）结构模式，并遵循课程中老师给出的设计框架，如下图所示： 由于要求游戏对象要动态生成，所以要预先把各种游戏对象制作成预制，放在Assets/Resources/Perfabs文件夹中，当游戏启动时通过场景控制器执行LoadResources函数实例化。 从Assert Store中下载(白嫖)游戏模型，还是有很多免费但精美的模型的，有些还自带了动作。 在模拟好整个场景，预先排练并记下每个游戏对象的合适位置后，我们就可以用代码来动态生成他们了，并为它们赋予各自的逻辑。 因为牧师与恶魔的行为基本一致，所以我们可以归为一类考虑，并且用数组存储其对象，便于组织和管理。 代码实例由于源代码过长，就不全部贴出来了，这里只展示一些关键函数。详细的可以见我的Github(在下面给出了)。 首先是导演类，比较简单，就是单例…不说了。 然后我先完成了Model层的设计，因为Model较为底层，个人认为类似于建筑的地基。在Model层中，需要完成对每一类游戏对象属性、行为的定义。对于此游戏，我一共定义了role、boat、land、river四个模型，各自封装到一个类中。 role类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105public class RoleModel&#123; GameObject role; bool good; bool onBoat; int side; Click click; Move move; public RoleModel(string roleType) &#123; onBoat = false; side = 1; if (roleType == \"priest\") &#123; role = Object.Instantiate( Resources.Load&lt;GameObject&gt;(\"Prefabs/Priest\"), Vector3.zero, Quaternion.Euler(0, 270, 0)); good = true; &#125; else if (roleType == \"devil\") &#123; role = Object.Instantiate( Resources.Load&lt;GameObject&gt;(\"Prefabs/Devil\"), Vector3.zero, Quaternion.Euler(0, 270, 0)); good = false; &#125; move = role.AddComponent(typeof(Move)) as Move; click = role.AddComponent(typeof(Click)) as Click; click.SetRole(this); &#125; public void Reset() &#123; side = 1; role.transform.parent = null; onBoat = false; &#125; //下面Attack、Idle、Lose三个函数为恶魔专属，用于设置恶魔动画，似乎有些不符合role的设定，用继承可能好一点 public void Attack() &#123; Animator anim = role.GetComponent&lt;Animator&gt;(); anim.SetBool(\"attack\", true); &#125; public void Idle() &#123; Animator anim = role.GetComponent&lt;Animator&gt;(); anim.SetBool(\"attack\", false); anim.SetBool(\"lose\", false); &#125; public void Lose() &#123; Animator anim = role.GetComponent&lt;Animator&gt;(); anim.SetBool(\"lose\", true); &#125; public bool IsGood() &#123; return good; &#125; public bool IsMoving() &#123; return move.IsMoving(); &#125; public string GetName() &#123; return role.name; &#125; public void SetName(string name) &#123; role.name = name; &#125; public int GetSide() &#123; return side; &#125; public void SetSide(int s = 0) &#123; if(s != 0) &#123; side = s; &#125; else side = 0 - side; &#125; public void ChangeDirction() &#123; if (side == 1) &#123; role.transform.rotation = Quaternion.Euler(0, 270, 0); &#125; else &#123; role.transform.rotation = Quaternion.Euler(0, 90, 0); &#125; &#125; public bool IsOnBoat() &#123; return onBoat; &#125; public void SetPosition(Vector3 pos) &#123; role.transform.position = pos; &#125; public Vector3 getPosition() &#123; return role.transform.position; &#125; public void Move(Vector3 position) &#123; move.setPosition(position); &#125; public void GoLand() &#123; role.transform.parent = null; onBoat = false; &#125; public void GoBoat(BoatModel boat) &#123; role.transform.parent = boat.GetBoat().transform; onBoat = true; &#125;&#125; boat类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145public class BoatModel&#123; GameObject boat; //bool moving; //船是否在运动 int side; //1表示在右边，-1表示在左边 Vector3 rightPosition = new Vector3(3, -1, 0); Vector3 leftPosition = new Vector3(-3, -1, 0); Vector3[] rightPositions = new Vector3[] &#123; new Vector3(2.5F, -0.8F, 0), new Vector3(3.5F, -0.8F, 0) &#125;; Vector3[] leftPositions = new Vector3[] &#123; new Vector3(-2.5F, -0.8F, 0), new Vector3(-3.5F, -0.8F, 0) &#125;; RoleModel[] passengers = new RoleModel[2]; Move move; public BoatModel() &#123; //初始船在右边 side = 1; boat = Object.Instantiate( Resources.Load&lt;GameObject&gt;(\"Prefabs/Boat\"), new Vector3(3, -1, 0), Quaternion.Euler(0, 270, 0)); boat.name = \"boat\"; move = boat.AddComponent(typeof(Move)) as Move; for (int i = 0; i &lt; 2; i++) passengers[i] = null; &#125; public int GetSide() &#123; return side; &#125; public void ChangeDirction() &#123; if(side == 1) &#123; boat.transform.rotation = Quaternion.Euler(0, 270, 0); &#125; else &#123; boat.transform.rotation = Quaternion.Euler(0, 90, 0); &#125; &#125; public bool IsEmpty() &#123; for(int i = 0; i &lt; 2; i++) if (passengers[i] != null) return false; return true; &#125; public bool IsFull() &#123; for (int i = 0; i &lt; 2; i++) if (passengers[i] == null) return false; return true; &#125; public bool IsMoving() &#123; return move.IsMoving(); &#125; public void Reset() &#123; side = 1; boat.transform.position = new Vector3(3, -1, 0); move.setPosition(leftPosition); move.SetMoveSate(0); passengers = new RoleModel[2]; &#125; public void Move() &#123; if(side == 1) &#123; move.setPosition(leftPosition); side = -1; &#125; else &#123; move.setPosition(rightPosition); side = 1; &#125; //同时改变role的side for (int i = 0; i &lt; 2; i++) &#123; if (passengers[i] != null) &#123; passengers[i].SetSide(); &#125; &#125; &#125; public int GetEmptyIndex() &#123; for (int i = 0; i &lt; passengers.Length; i++) &#123; if (passengers[i] == null) &#123; return i; &#125; &#125; return -1; &#125; public Vector3 getEmptyPosition() &#123; Vector3 pos; int emptyIndex = GetEmptyIndex(); if (side == 1) &#123; pos = rightPositions[emptyIndex]; &#125; else &#123; pos = leftPositions[emptyIndex]; &#125; return pos; &#125; public GameObject GetBoat() &#123; return boat; &#125; public void AddPassenger(RoleModel passenger) &#123; if (!IsFull()) passengers[GetEmptyIndex()] = passenger; &#125; public RoleModel DeletePassenger(RoleModel passenger) &#123; for (int i = 0; i &lt; 2; i++) if (passengers[i] != null &amp;&amp; passengers[i].GetName() == passenger.GetName()) &#123; RoleModel role = passengers[i]; passengers[i] = null; return role; &#125; return null; &#125; public RoleModel[] GetPassengers() &#123; return passengers; &#125;&#125; 河岸land类以及河river类都没什么特别的，因为它们都没有什么行为，只需要简单的初始化即可，这里就不展示了。 但光有对象不行，我们还需要给它们附加行为，才可以让他们动起来，同时还需要使role响应玩家鼠标的点击。就有了下面的Move和Click类。观察之前的role类，我们可以发现在初始化boat和role时，我们就实例化了这两个类，并作为组件(Component)附加到了游戏对象上，类似之前直接创建的脚本。 Move类 Move类实现游戏对象的平滑移动，主要依靠的是内置的MoveToward函数，在每次``Update`时都会执行，使得对象逐渐朝目的地移动。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Move : MonoBehaviour&#123; float speed = 4; //移动速度 Vector3 endPosition, middlePosition; int moveState = 0; //0表示不移动, 1表示水平移动，2表示竖直移动 public void SetMoveSate(int state) &#123; moveState = state; &#125; public bool IsMoving() &#123; return moveState != 0; &#125; public void setPosition(Vector3 position) &#123; endPosition = position; if (position.y == transform.position.y) //y值不变：船的移动 &#123; SetMoveSate(2); &#125; else &#123; if (position.y &lt; transform.position.y) //y值减小：角色从陆地到船 &#123; middlePosition = new Vector3(position.x, transform.position.y, position.z); &#125; else //y值增大：角色从船到陆地 &#123; middlePosition = new Vector3(transform.position.x, position.y, position.z); &#125; SetMoveSate(1); &#125; &#125; void Update() &#123; if (moveState == 1) &#123; transform.position = Vector3.MoveTowards(transform.position, middlePosition, speed * Time.deltaTime); if (transform.position == middlePosition) SetMoveSate(2); &#125; else if (moveState == 2) &#123; transform.position = Vector3.MoveTowards(transform.position, endPosition, speed * Time.deltaTime); if (transform.position == endPosition) SetMoveSate(0); &#125; &#125;&#125; Click类 Click类绑定一个相关的role对象，通过OnMouseDown函数实现响应鼠标点击，执行相关动作。 值得注意的是，要想OnMouseDown函数工作，还需要给游戏对象添加碰撞体(Collider)才行。 123456789101112131415161718192021public class Click : MonoBehaviour&#123; IUserAction action; RoleModel role; public void SetRole(RoleModel r) &#123; role = r; &#125; void Start() &#123; action = SSDirector.GetInstance().CurrentSceneController as IUserAction; &#125; void OnMouseDown() &#123; if (role == null) &#123; return; &#125; action.MoveRole(role); &#125;&#125; 现在Model层就基本完成了。我们再来考虑View层，即游戏与玩家的交互，我们需要为玩家提供什么交互功能。 IUserAction 1234567891011using System.Collections;using System.Collections.Generic;using UnityEngine;public interface IUserAction&#123; void MoveBoat(); void MoveRole(RoleModel role); int Check(); void Restart();&#125; UserGUI: 由于我们的FirstSceneController也实现了IUserACtion接口，相当于控制器帮助玩家实现了指定的工作。所以我们在UserGUI中，只需要得到这个控制器，当玩家进行某个操作时，调用控制器的接口函数即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354using System.Collections;using System.Collections.Generic;using UnityEngine;public class UserGUI : MonoBehaviour&#123; private IUserAction action; int sign = 0; //0：游戏进行中， 1：游戏胜利 -1：游戏失败 // Start is called before the first frame update void Start() &#123; action = SSDirector.GetInstance().CurrentSceneController as IUserAction; &#125; void OnGUI() &#123; GUIStyle text_style; GUIStyle button_style; text_style = new GUIStyle() &#123; fontSize = 30 &#125;; button_style = new GUIStyle(\"button\") &#123; fontSize = 15 &#125;; sign = action.Check(); if (sign == 0) &#123; if (GUI.Button(new Rect(Screen.width / 2 - 30, 80, 60, 60), \"Go!\")) &#123; action.MoveBoat(); &#125; &#125; else if(sign == -1) &#123; GUI.Label(new Rect(Screen.width / 2 - 75, 100, 120, 50), \"You Failed!\", text_style); if (GUI.Button(new Rect(Screen.width / 2 - 50, 150, 100, 50), \"Try Agian\", button_style)) &#123; action.Restart(); sign = 0; &#125; &#125; else if(sign == 1) &#123; GUI.Label(new Rect(Screen.width / 2 - 60, 100, 120, 50), \"You Win!\", text_style); if (GUI.Button(new Rect(Screen.width / 2 - 50, 150, 100, 50), \"Restart\", button_style)) &#123; action.Restart(); sign = 0; &#125; &#125; &#125;&#125; 最后我们完成Controller层，将之前的两层衔接起来。这里实现的是FirstController类，主要完成了加载资源，移动人物和船，判断游戏是否结束等功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196using System.Collections;using System.Collections.Generic;using UnityEngine;public class FirstController : MonoBehaviour, ISceneController, IUserAction&#123; public RoleModel[] Priests = new RoleModel[3]; public RoleModel[] Devils = new RoleModel[3]; public RiverModel River; public LandModel RightLand; public LandModel LeftLand; public BoatModel Boat; Vector3[] PrisetsOriginPositions = new Vector3[] &#123; new Vector3(5F, 0, 0), new Vector3(5.5F, 0, 0), new Vector3(6F, 0, 0) &#125;; Vector3[] DevilsOriginPositions = new Vector3[] &#123; new Vector3(7F, 0, 0), new Vector3(7.5F, 0, 0), new Vector3(8F, 0, 0) &#125;; bool gaming = true; //用于判断游戏是否正在进行，由于目前还不存在起始界面，所以一开始游戏就开始了 void Awake() &#123; SSDirector director = SSDirector.GetInstance(); //director.setFPS(60); director.CurrentSceneController = this; director.CurrentSceneController.LoadResource(); &#125; public void LoadResource() &#123; for(int i = 0; i &lt; 3; i++) &#123; RoleModel priest = new RoleModel(\"priest\"); priest.SetName(\"priest\" + i); priest.SetPosition(new Vector3(5 + i * 0.5F, 0, 0)); Priests[i] = priest; RoleModel devil = new RoleModel(\"devil\"); devil.SetName(\"devil\" + i); devil.SetPosition(new Vector3(7 + i * 0.5F, -0.1F, 0)); devil.Idle(); Devils[i] = devil; &#125; RightLand = new LandModel(\"right\"); LeftLand = new LandModel(\"left\"); River = new RiverModel(); Boat = new BoatModel(); &#125; // Start is called before the first frame update void Start() &#123; &#125; // Update is called once per frame void Update() &#123; &#125; public void Restart() &#123; for (int i = 0; i &lt; 3; i++) &#123; Priests[i].Reset(); Priests[i].SetPosition(PrisetsOriginPositions[i]); Devils[i].Reset(); Devils[i].SetPosition(DevilsOriginPositions[i]); Devils[i].Idle(); &#125; Boat.Reset(); gaming = true; &#125; public int Check() &#123; //等船停下来再check if (Boat.IsMoving()) return 0; Boat.ChangeDirction(); //计算两边的牧师和恶魔数量 int rightPriestNum = 0, leftPriestNum = 0, rightDevilNum = 0, leftDevilNum = 0; for(int i = 0; i &lt; 3; i++) &#123; Priests[i].ChangeDirction(); Devils[i].ChangeDirction(); if(Priests[i].GetSide() == 1) &#123; rightPriestNum++; &#125; else &#123; leftPriestNum++; &#125; if (Devils[i].GetSide() == 1) &#123; rightDevilNum++; &#125; else &#123; leftDevilNum++; &#125; &#125; if (leftPriestNum + leftDevilNum == 6) &#123; for (int i = 0; i &lt; 3; i++) &#123; Devils[i].Lose(); &#125; gaming = false; return 1; //win &#125; else if ((leftPriestNum &gt; 0 &amp;&amp; leftDevilNum &gt; leftPriestNum) || (rightPriestNum &gt; 0 &amp;&amp; rightDevilNum &gt; rightPriestNum)) &#123; int attackSide; if (leftDevilNum &gt; leftPriestNum) attackSide = -1; else attackSide = 1; for(int i = 0; i &lt; 3; i++) &#123; if(Devils[i].GetSide() == attackSide) Devils[i].Attack(); &#125; gaming = false; return -1; //lose &#125; else &#123; return 0; //continue &#125; &#125; public void MoveRole(RoleModel role) &#123; if (!gaming) return; //当其他角色还在移动时，不允许移动 for (int i = 0; i &lt; 3; i++) &#123; if (Priests[i].IsMoving() || Devils[i].IsMoving()) return; &#125; //如果还在前进，return if (Boat.IsMoving()) return; if (role.IsOnBoat()) //上岸 &#123; //这里，为了和原游戏一致，使牧师和魔鬼在两边的排列顺序一致 role = Boat.DeletePassenger(role); Vector3 direction; int id = role.GetName()[role.GetName().Length - 1] - '0'; if (role.IsGood()) &#123; direction = PrisetsOriginPositions[id]; &#125; else &#123; direction = DevilsOriginPositions[id]; &#125; if(role.GetSide() == -1) &#123; direction.x = 0 - direction.x; &#125; role.Move(direction); role.GoLand(); &#125; else //上船 &#123; if (Boat.IsFull() || Boat.GetSide() != role.GetSide()) &#123; return; &#125; role.Move(Boat.getEmptyPosition()); role.GoBoat(Boat); Boat.AddPassenger(role); &#125; &#125; public void MoveBoat() &#123; //当船为空，或者船已经在动时，不允许移动船 if (!Boat.IsEmpty() &amp;&amp; !Boat.IsMoving()) &#123; //当角色还在移动时，不允许移动船 for (int i = 0; i &lt; 3; i++) &#123; if (Priests[i].IsMoving() || Devils[i].IsMoving()) return; &#125; Boat.Move(); &#125; &#125;&#125; 完成上述代码后，游戏的逻辑也基本完成了。 细节部分 船未靠岸，牧师与魔鬼上下船运动中，均不能接受用户事件：只需要在UserAction的函数中判断Move类中的state即可(具体代码见上面)，如果state表明正在移动，则直接返回，不进行任何操作。 同样的，当游戏胜利或者失败后，同样不能接受除了Restart以外的任何用户事件。 模型动作在下载模型时，发现了模型好像自带有动画(Animator组件)，于是就上网查了以下如何给人物附加动画。大致就是创建一个Animator Controller，通过给模型创建状态，并为不同状态绑定不同的动画效果，状态之间的转换需要一些特定的条件，在代码中触发这些条件实现动画切换。 上述可能解释的不是很清楚，具体可以参考这个博客 游戏主界面 完整游戏视频 项目地址 游戏优化 人物的移动做的还是比较粗糙，特别是河岸和船之间的路，我参考了往届同学的思路，使用了一个中间点用于转折，但应该还可以有更好的实现。 可以模仿原游戏，增加计时功能；也可以在起始时增加选项，根据玩家选择的难度增加牧师与恶魔的数量，以增加游戏难度与趣味。 在开始和结束游戏时，制作额外的场景用于和玩家交互 下次的作业还是这个游戏，希望可以完成一些上述提到的想法，欢迎关注后续文章。 感想这应该算是一个比较完整的游戏了，整体做下来以后，感觉按这样的思路设计游戏的话，还是十分复杂的。虽然现在对于Unity的使用还只是停留在移动、旋转对象的层面，但即使这样一个逻辑十分简单的游戏，仍有很多细节需要去判断，需要制定好每个对象的行为和位置，否则很容易出现Bug，就更不用说那些复杂的游戏了，简直不敢想象。我自身对于MVC模式掌握的也不够熟练，很多函数写的也比较繁琐。 但整个游戏的制作过程还是很愉快的，特别是在Asset Store下载了一些模型后，对于把游戏做精美的欲望更加强烈了。模型的使用、模型动画机制的运用让我对于接下来的学习3D游戏设计以及Unity的使用更加期待了。","categories":[{"name":"3D游戏编程","slug":"3D游戏编程","permalink":"http://yoursite.com/categories/3D游戏编程/"}],"tags":[{"name":"课程作业","slug":"课程作业","permalink":"http://yoursite.com/tags/课程作业/"},{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"}]},{"title":"初次接触Go语言","slug":"初次接触Go语言","date":"2019-09-12T09:09:35.000Z","updated":"2020-02-18T14:30:44.229Z","comments":true,"path":"2019/09/12/初次接触Go语言/","link":"","permalink":"http://yoursite.com/2019/09/12/初次接触Go语言/","excerpt":"在配置完Go语言编程环境后，我阅读了官方文档 如何使用Go编程 ，并按文档写第一个包，做第一次测试。 项目地址：https://github.com/DanielXuuuuu/ServiceComputingOnCloud","text":"在配置完Go语言编程环境后，我阅读了官方文档 如何使用Go编程 ，并按文档写第一个包，做第一次测试。 项目地址：https://github.com/DanielXuuuuu/ServiceComputingOnCloud 准备工作首先，需要了解一些基础知识： 编程环境 工作空间：Go代码必须放在工作空间内。它其实就是一个目录，其中包含三个子目录： src 目录包含Go的源文件，它们被组织成包（每个目录都对应一个包）; pkg 目录包含编译后生成的包/库文件； bin 目录包含编译后生成的可执行文件。 环境变量：GOPATH 环境变量指定了你的工作空间位置（工作空间目录），需要添加到系统的PATH中。GOPATH 适合处理大量 Go语言源码、多个包组合而成的复杂工程。 GO相关 包 Package Go语言是使用包来组织源代码的，并实现命名空间的管理。任何源代码文件必须属于某个包。源码文件的第一行有效代码必须是 package pacakgeName 语句，通过该语句声明自己所在的包。Go 语言的入口 main() 函数所在的包（package）叫 main，main 包想要引用别的代码，必须同样以包的方式进行引用。 包一般放到公司的域名目录下，这样能保证包名的唯一性，便于共享代码。比如个人的 GitHub 项目的包一般放到 $GOPATH/src/github.com/userName/projectName 目录下。 包的定义是不包括目录路径的，但是包的引用一般是全路径引用 go工具：在命令行下，go提供了很多自带的命令行工具： 12345678910111213141516171819202122232425Go is a tool for managing Go source code.Usage: go &lt;command&gt; [arguments]The commands are: bug start a bug report build compile packages and dependencies clean remove object files and cached files doc show documentation for package or symbol env print Go environment information fix update packages to use new APIs fmt gofmt (reformat) package sources generate generate Go files by processing source get download and install packages and dependencies install compile and install packages and dependencies list list packages or modules mod module maintenance run compile and run Go program test test packages tool run specified go tool version print Go version vet report likely mistakes in packages 我的第一个程序以下是已设置好的环境变量： 首先在src目录下创建一个文件夹，并在其中新建一个文件 123mkdir $GOPATH/src/github.com/DanielXuuuuu/hellocd $GOPATH/src/github.com/DanielXuuuuu/hellotouch hello.go 通过vim或者VSCode输入以下代码 1234567package mainimport \"fmt\"func main() &#123; fmt.Printf(\"Hello, world.\\n\")&#125; 保存后，在终端执行go install github.com/DanielXuuuuu/hello，go工具会根据GOPATH指定的工作空间，到src子文件夹查找源码。此命令会构建 hello 命令，产生一个可执行的二进制文件。 接着它会将该二进制文件作为 hello（在 Windows 下则为 hello.exe）安装到工作空间的 bin 目录中。 由于已经将 $GOPATH/bin 添加到 PATH 中了，只需输入该二进制文件名即可运行。 我的第一个包首先创建包目录： 1$ mkdir $GOPATH/src/github.com/DanielXuuuuu/stringutil 接着，在该目录中创建名为 reverse.go 的文件： 1234567891011// stringutil 包含有用于处理字符串的工具函数。package stringutil// Reverse 将其实参字符串以符文为单位左右反转。func Reverse(s string) string &#123; r := []rune(s) for i, j := 0, len(r)-1; i &lt; len(r)/2; i, j = i+1, j-1 &#123; r[i], r[j] = r[j], r[i] &#125; return string(r)&#125; 执行go build github.com/DanielXuuuuu/stringutil进行编译。编译完后，stringutil 包就构建完毕了，我们修改原来的 hello.go 文件： 1234567891011package mainimport ( \"fmt\" \"stringutil\")func main() &#123; fmt.Printf(stringutil.Reverse(\"!oG ,olleH\"))&#125; 保存后再次执行go install ...，并运行，结果为： 编写测试Go拥有一个轻量级的测试框架，它由 go test 命令和 testing 包构成。通过创建一个名字为XXX_test.go 用于测试XXX.go。因此，我们在stringutil目录下创建名为 reverse_test.go 的文件，代码如下： 12345678910111213141516171819package stringutilimport \"testing\"func TestReverse(t *testing.T) &#123; cases := []struct &#123; in, want string &#125;&#123; &#123;\"Hello, world\", \"dlrow ,olleH\"&#125;, &#123;\"Hello, 世界\", \"界世 ,olleH\"&#125;, &#123;\"\", \"\"&#125;, &#125; for _, c := range cases &#123; got := Reverse(c.in) if got != c.want &#123; t.Errorf(\"Reverse(%q) == %q, want %q\", c.in, got, c.want) &#125; &#125;&#125; 执行go test github.com/DanielXuuuuu/stringutil进行测试，结果如下： 输出为ok，表明通过测试。","categories":[{"name":"服务计算","slug":"服务计算","permalink":"http://yoursite.com/categories/服务计算/"}],"tags":[{"name":"Go语言","slug":"Go语言","permalink":"http://yoursite.com/tags/Go语言/"}]},{"title":"Sevice Computing - 在Linux中安装配置Go开发环境","slug":"Sevice-Computing-在Linux中安装配置Go开发环境","date":"2019-09-10T11:43:41.000Z","updated":"2020-02-18T14:29:59.520Z","comments":true,"path":"2019/09/10/Sevice-Computing-在Linux中安装配置Go开发环境/","link":"","permalink":"http://yoursite.com/2019/09/10/Sevice-Computing-在Linux中安装配置Go开发环境/","excerpt":"本文主要记录了我在Linux中配置Go开发环境过程中遇到的一些问题和奇怪的坑。由于CentOS虚拟机较卡，后来换用了Ubuntu。","text":"本文主要记录了我在Linux中配置Go开发环境过程中遇到的一些问题和奇怪的坑。由于CentOS虚拟机较卡，后来换用了Ubuntu。 完整过程指导 CentOSyum不可使用 在安装好CentOS和Chrome后，yum突然不可用了，更换了好几次源还是不行。 经过上网查询，这可能是安装了Chrome导致的，参考了别人的解决方法后才解决： 12rm -rf /etc/yum.repos.d/google-chrome.repoyum clean all Golang的安装 在使用命令sudo yum install golang时提示没有可用软件包，并且已经执行过yum update了。 这代表在linux系统yum源中已经没有对应的安装包了，这时我们需要安装EPEL(Extra Packages for Enterprise Linxu，企业版Linux额外包)： 1yum install -y epel-release Git安装 通常情况下通过使用命令sudo yum install git来安装的git版本都较低，我在使用VSCode时，提示我需要升级。于是我参考此博客进行了升级，但升级过程中，在执行make prefix=/usr/local/git all进行编译时，出现了以下两个问题： 找不到openssl/ssl.h文件。解决方法：yum install openssl-devel 找不到curl/curl.h。解决方法：yum -y install curl-devel VSCode中安装Go相关插件 在使用VSCode打开.go文件后，按照提示下载插件，最后提示有一个安装包安装失败Installing github.com/ramya-rao-a/go-outline FAILED。然后按照指导页面使用go get -d github.com/golang/tools将源代码下载到本地后安装还是不行。 解决方法：通过手动安装 12go get -u github.com/ramya-rao-a/go-outlinego install github.com/ramya-rao-a/go-outline Ubuntu环境变量 在设置GOPATH环境变量时，按照教程先后执行export GOPATH=/home/daniel/go和export PATH=$PATH:$GOPATH/bin后，仅仅只在当前终端生效。关闭后重新打开终端，上述配置失效。 解决方法： 1234567# 通过修改.bashrc文件vim ~/.bashrc# 在最后面加上下面两句：export GOPATH=/home/daniel/go # 这是我的设置export PATH=$PATH:$GOPATH/bin# 保存退出后，执行以下命令source ~/.bashrc 上述解决方法对当前用户永久有效，若是想要对所有用户永久有效，就要修改etx/profile文件，修改方式相同。","categories":[{"name":"服务计算","slug":"服务计算","permalink":"http://yoursite.com/categories/服务计算/"}],"tags":[{"name":"Go语言","slug":"Go语言","permalink":"http://yoursite.com/tags/Go语言/"}]},{"title":"3D Game Programming & Design - 离散仿真引擎基础","slug":"3D-Game-Programming-Design-离散仿真引擎基础","date":"2019-09-04T01:56:32.000Z","updated":"2020-02-18T14:32:36.271Z","comments":true,"path":"2019/09/04/3D-Game-Programming-Design-离散仿真引擎基础/","link":"","permalink":"http://yoursite.com/2019/09/04/3D-Game-Programming-Design-离散仿真引擎基础/","excerpt":"3D游戏编程的第二次作业，初次接触Unity3D.","text":"3D游戏编程的第二次作业，初次接触Unity3D. 解释游戏对象(GameObjects) 和资源(Assets)的区别与联系 游戏对象：指出现在游戏场景中的每一个功能对象，例如人物、道具、场景等。游戏对象本身不做任何事情，就像一个空盒子，通过在里面装入需要的组件（Components）来实现具体的功能。类似于资源的集合体，是资源整合的具体表现。 资源：指任何可以被加入到游戏中的素材资源，可以被多个对象使用。资源既可以来自unity3D外部，例如3D模型，音频，图像等，也可以来自内部，例如动画控制器，纹理渲染等。资源可用于实例化游戏中的具体对象。 下载几个游戏案例，分别总结资源、对象组织的结构(指资源的目录组织结构与游戏对象树的层次结构) 资源的目录组织结构：包括图片、场景、脚本、模型、素材等 游戏对象树的层次结构：包括摄像机包，场景布局，文本等 编写一个代码，使用debug语句来验证MonoBehaviour基本行为或事件触发的条件​ 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class test : MonoBehaviour&#123; void Awake() &#123; Debug.Log(\"onAwake\"); &#125; // Start is called before the first frame update void Start() &#123; Debug.Log(\"onStart\"); &#125; // Update is called once per frame void Update() &#123; Debug.Log(\"onUpdate\"); &#125; void FixedUpdate() &#123; Debug.Log(\"onFixedUpdate\"); &#125; void LateUpdate() &#123; Debug.Log(\"onLateUpdate\"); &#125; void OnGUI() &#123; Debug.Log(\"onGUI\"); &#125; void OnDisable() &#123; Debug.Log(\"onDisable\"); &#125; void OnEnable() &#123; Debug.Log(\"onEnable\"); &#125;&#125; MonoBehaviour是Unity中所有行为对象的基类，其中有以下可重写函数： 基本行为 Awake()：当一个脚本实例被载入时调用，因此大多用于成员变量的初始化 Start()：在所有Update函数之前，在Awake之后被调用一次，可以把一些需要依赖Awake的变量放在Start里面初始化 Update()：当行为启动时，其Update在每一帧被调用 FixedUpdate()：当行为启动时，其FixedUpdate在每一时间片（每一固定帧）被调用 LateUpdate()：当行为启动时，在所有Update函数之后执行，例如：摄像机的跟随 常用事件 OnGUI()：绘制GUI时调用 OnDisable()：当对象变为不可用或非激活状态时调用；当物体销毁时调用； OnEnable()：当对象变为可用或激活状态时调用 OnDestory()：当对象被销毁时调用 查找脚本手册，了解GameObject，Transform，Component 对象分别翻译官方对三个对象的描述（Description） GameObject：GameObjects are the fundamental objects in Unity that represent characters, props and scenery. They do not accomplish much in themselves but they act as containers for Components, which implement the real functionality. 游戏对象是Unity中的基本对象，代表了角色，道具和场景。它们本身的功能并不完整，但它们充当了组件的容器，得以实现真正的功能。 Transform：Every object in a Scene has a Transform. It’s used to store and manipulate the position, rotation and scale of the object. 场景中的每个对象都有一个变换，用于存储和操纵对象的位置，旋转和缩放。 Component：Base class for everything attached to GameObjects. Note that your code will never directly create a Component. Instead, you write script code, and attach the script to a GameObject. 绑定到游戏对象上的一组相关属性，通过编写脚本代码来创建组件。 描述下图中 table 对象（实体）的属性、table 的 Transform 的属性、 table 的部件 table的对象是GameObject。在第一行中：第一个选择框是activeSelf属性，第二个文本框是对象名称，第三个选择框是static属性；第二行中：从左至右为Tag属性和Layer属性；第三行为prefab（预设）属性。 table的Transform属性包含position（位置），Rotation（旋转）以及Scale（比例） table的部件Component对象有Transform，Mesh Filter，Box Collider，Mesh Renderer，Default-Material。 用 UML 图描述 三者的关系 整理相关学习资料，编写简单代码验证以下技术的实现：查找对象 按名字查找 public static GameObject Find(string name) 按标签查找单个对象 public static GameObject FindWithTag(string tag) 按标签查找多个对象：public static GameObject[] findGameObjectsWithTag(string tag) 添加子对象 public static GameObject CreatePrimitive(PrimitiveType type) 遍历对象树123foreach (Transform child in transform)&#123; Debug.Log(child.gameObject.name);&#125; 清除所有子对象123foreach (Transform child in transform)&#123; Destory(child.gameObject);&#125; 资源预设(Prefabs)与对象克隆(clone)预设（Prefabs）有什么好处？ 预设是Unity中的一种特殊资源，通常就是一个或者一系列组件的集合体，类似于一个模板。预设创建后，可以对其进行实例化出一些具有相同属性的对象，这些对象与预设关联。若预设发生改变，所有关联的对象都会发生相应变化。 好处： 批量处理方便 使对象和资源能重复利用，提高效率 预设与对象克隆 (clone or copy or Instantiate of Unity Object) 关系？ 预设是从无到有的创建，供以后的需要；而对象克隆需要场景中实现存在被克隆对象 预设创建出来的对象会随着与之相关联的预设的变化而变化，而克隆出的相当于一个独立的新对象，不会因被克隆对象的改变而改变 制作 table 预制，写一段代码将 table 预制资源实例化成游戏对象1GameObject anotherTable = (GameObject)Instantiate(table.gameObject); 编程实践—小游戏游戏内容： 简单计算器 技术限制： 仅允许使用 IMGUI 构建 UI 作业目的： 提升 debug 能力 提升阅读 API 文档能力 项目地址：Tic Tac Toe 运行后结果如下： 初始界面： 胜出界面： 思考题【选作】微软 XNA 引擎的 Game 对象屏蔽了游戏循环的细节，并使用一组虚方法让继承者完成它们，我们称这种设计为“模板方法模式”。 为什么是“模板方法”模式而不是“策略模式”呢？ 策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。 模板方法模式在一个方法中定义一个算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。 结合以上定义，我们可以看到这两个模式虽然同样都用到了继承和虚函数的技术，但应用场景有着较大的区别，策略模式主要是定义一系列相同接口的算法，通过委托（delegate）来达到动态改变算法；而模板方法模式用于定义一个大框架，子类根据实际情况具体实现这个框架。 对于微软XNA引擎的Game基类，其真实的目的是为游戏提供一个基础框架，给用户一个编程模板，用户去实现具体的函数即可。因此是模板方法模式。 这启发我们，思考和辨别设计模式的时候，应该看问题的背景和上下文，而不是技术的解决方法。 将游戏对象组成树型结构，每个节点都是游戏对象（或数） 尝试解释组合模式（Composite Pattern / 一种设计模式） 组合模式，又叫部分-整体模式，将对象组合成树形结构以表示“部分-整体”的层次结构，把一组相似的对象当作一个单一的对象，用户对单个对象和组合对象的使用具有一致性。其关键点在于简单对象和复合对象必须实现相同的接口 使用 BroadcastMessage() 方法，向子对象发送消息。你能写出 BroadcastMessage() 的伪代码吗? 1234567891011121314//父对象void test()&#123; Debug.Log(\"我是父对象\");&#125;void Start()&#123; this.BroadcastMessage(\"test\");&#125;//子对象void test()&#123; Debug.Log(\"我是子对象\");&#125; 一个游戏对象用许多部件描述不同方面的特征。我们设计坦克（Tank）游戏对象不是继承于GameObject对象，而是 GameObject 添加一组行为部件（Component）。 这是什么设计模式？ Decorator 装饰器模式，通过在原有类的基础上通过包装组合增加功能，以实现更多的功能 为什么不用继承设计特殊的游戏对象？ 使用继承来设计各种特殊的游戏对象，会导致产生很多父类和子类，而且产生的继承关系十分复杂，增加编程人员的编程难度。 同时，一旦需要增加新的行为，可能会需要去修改很多相关类，耦合性强，使得编程效率变得很低。","categories":[{"name":"3D游戏编程","slug":"3D游戏编程","permalink":"http://yoursite.com/categories/3D游戏编程/"}],"tags":[{"name":"课程作业","slug":"课程作业","permalink":"http://yoursite.com/tags/课程作业/"},{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"}]},{"title":"Human Resource Machine - 一款杂糅了编程元素的另类解谜游戏","slug":"Human Resource Machine - 一款杂糅了编程元素的另类解谜游戏","date":"2019-09-01T08:01:27.000Z","updated":"2020-02-18T14:31:35.891Z","comments":true,"path":"2019/09/01/Human Resource Machine - 一款杂糅了编程元素的另类解谜游戏/","link":"","permalink":"http://yoursite.com/2019/09/01/Human Resource Machine - 一款杂糅了编程元素的另类解谜游戏/","excerpt":"给小职员编程来让他们解决难题。当一名好的员工吧！机器正在过来……夺走你的岗位。","text":"给小职员编程来让他们解决难题。当一名好的员工吧！机器正在过来……夺走你的岗位。 前言人力资源机器，又名程序员升职记，是一款好玩的解谜游戏，玩法相当新颖。玩家将扮演一个从基层做起的员工，需要通过指令代码来编写一条条程序，完成每个阶段的任务，最终走上职场巅峰。 即使是从未接触过编程的你，也不懂担心，这款游戏从最简单的关卡开始，带你一步一步领略逻辑的美妙和编程的乐趣。当去掉所有的 0 和 1 和吓人的弯弯曲曲的括号，编程很简单，很合乎逻辑，很美丽，而且是任何人都可以理解并从中获得乐趣的事！ 在2017年3月3日，第13届国际移动游戏大奖公布《人力资源机器》获得了创新卓越奖。 游戏设计元素我们以其中较为简单的一个关卡为例，游戏界面如下： 玩家 - 左上角小人，是一位积极努力想要升职的人 老板 - 坐在桌子前的小人，每次都会给你布置各种难题的人 左边箭头处 - INBOX，输入 右边箭头处 - OUTBOX，输出 右边 - 老板布置的任务，以及你的工作区 左下角 - 用于开始，调试，暂停你的工作 地砖 - 用作储存数据的介质，有时开发空地砖是有成本的(读取数据+写入寄存器)，但不开发的地砖无法运算，在下一张图中我们会看到地砖。 游戏玩法游戏主要采用拖拽加点击的方式进行，玩家要做的就是根据“工作指示”拖拽有用的代码至指令输入栏。当完整的指令确认无误后，则需点击界面左下方的“运行”按钮，游戏中的员工就会按照你设计好的步骤去完成任务。 有些关卡你可能不能一次性就完成正确指令，这时候我们就会用到左下角的“停止并重置”按钮，我们也可以“返回上一步调试”。如果你需要一步步斟酌，检测所编程序的准确性，在程序编写完成后，可以一次次点击“下一步”按钮进行验证，或者你对自己的指令信心满满，在运行程序之后，还可以大胆加速员工的工作速度。 不难发现，整个游戏完全对应了一个程序员平时的解题步骤，而整个游戏界面就好像是你的编译器，左下角就是调试台，而玩家要做的就是合理的选择可供选择的指令（指令的数量会慢慢增加），并且对于指令进行排序，使得它们按照你给定的顺序执行后可以达到老板的预期目标，及对于输入要得到正确的输出。 以上图的关卡为例，我们的任务是从INBOX，也就是左边的流水线中，依次取出每个东西，放入到右边的流水线—OUTBOX中去。那么很简单，图中已经给出了该关的答案。熟悉编程的你肯定已经发现了，这就是一个简单的LOOP循环程序。 随着你不断地完成任务，升职加薪，你的任务难度也会逐渐提高，下面是一个更为高级的任务，指令也更多啦： 不知道你有没有发现一个小细节，此时，程序员的头发都已经变白变秃了！但神奇的是，老板的头发却越来越多。 社会贡献与价值最显著直观的价值当然是帮助我们了解编程之美啦，在计算机时代，掌握一些最基础的编程知识肯定是锦上添花的。随着游戏进度深入，游戏难度越来越高，主线和支线的搭配给玩家不同难度的关卡；与此同时，还逐步加入新指令，给玩家体验到每一种指令的作用，并实现了更多的算法。玩家仅能使用输入输出加减和零负跳转等的指令，但是需要完成乘除法、排序等比较高级复杂的算法，可以说是非常基础和底层的编程了。这对于玩家理解计算机的运行方式是很有意义的。 容积和运行速度是游戏的另一大特色。每一关会有容积和运行速度两个指标，很多时候算法做不到一箭双雕，甚至实现指标本身也是困难的事情。非常富有挑战性，适合比较熟练和希望挑战自己的玩家。 用半代码语言半框图的形式展现编程过程是游戏作为编程启蒙最棒的特点。直观易懂，能看到每一步过程是如何执行实现的，调试方便，还有标签功能。很好地体现了算法比编程内容本身更重要的特点。 总体而言，这是一款在闲暇之余值得玩的好游戏！","categories":[{"name":"3D游戏编程","slug":"3D游戏编程","permalink":"http://yoursite.com/categories/3D游戏编程/"}],"tags":[{"name":"编程游戏","slug":"编程游戏","permalink":"http://yoursite.com/tags/编程游戏/"},{"name":"解谜","slug":"解谜","permalink":"http://yoursite.com/tags/解谜/"}]},{"title":"Sevice Computing - Windows环境下使用VirtualBox搭建云桌面","slug":"Sevice-Computing-Windows环境下使用VirtualBox搭建云桌面","date":"2019-09-01T04:44:38.000Z","updated":"2020-02-18T14:32:02.409Z","comments":true,"path":"2019/09/01/Sevice-Computing-Windows环境下使用VirtualBox搭建云桌面/","link":"","permalink":"http://yoursite.com/2019/09/01/Sevice-Computing-Windows环境下使用VirtualBox搭建云桌面/","excerpt":"这是我在服务计算课程学习中的第一次实验，记录了我跟随老师的教程一步一步的在Windows环境下使用VirtualBox搭建云桌面的过程，过程虽并不难，但也遇到了一些小问题。","text":"这是我在服务计算课程学习中的第一次实验，记录了我跟随老师的教程一步一步的在Windows环境下使用VirtualBox搭建云桌面的过程，过程虽并不难，但也遇到了一些小问题。 实验目的 初步了解虚拟化技术，理解云计算的相关概念 理解系统工程师面临的困境 理解自动化安装、管理（DevOps）在云应用中的重要性 实验环境与要求 用户通过互联网，使用微软远程桌面，远程访问你在PC机上创建的虚拟机 主机：Windows 10；虚拟机软件：VirtualBox，虚拟机操作系统：Centos 实验步骤及结果安装VirtualBox 首先安装好git客户端（git bash）以及VirtualBox，由于这两个我之前都已安装好，且安装过程较为简单，这里就不再赘述了。 创建虚拟机内部虚拟网络，使得Vbox内部虚拟机可以通过它，实现虚拟机之间、虚拟机与主机的通讯。 VirtualBox菜单 ：管理 -&gt; 主机网络管理器，创建一块虚拟网卡，网址分配：192.168.100.1/24，如下图所示： 点击应用后，在主机 Windows 命令行窗口输入 ipconfig 可以看到 VirtualBox Host-Only Network #2 的网卡： 创建并配置Centos虚拟机 首先下载Centos镜像（只需Minimal ISO即可）：Centos官网 使用Vbox创建虚拟机，此过程与一般虚拟机创建流程一致，建议内存不低于2G，存储不低于30G，虚拟机的命名我设置为centos_base。 创建完成后，右键点击虚拟机选择设置，选择网络，第一块网卡必须是 NAT，然后启用第二块网卡，连接方式为 Host-Only，并选用之前创建的虚拟网卡。 启动虚拟机，根据指令进行安装，并完成用户名，密码等一系列的设置。 登陆系统，通过 nmtui 指令进入配置网络的UI界面： 选择“Edit a connection”，然后对其中的enp0s8进行编辑，修改其地址为192.168.100.5/24： 保存后返回上一级，选择“Activate a connection”，将enp0s3和enp0s8都激活，如下图所示： 退出配置界面，此时，ping Windows主机 和 ping 外网应该是都可以 ping 通的： 完成上述操作后，还可以进行OS系统的升级，依次执行命令yum install wget，yum update。这时，第一台虚拟机就配置好了，关闭该虚拟机。 复制Centos虚拟机 右键点击centos_base虚拟机，选择复制，输入新虚拟机的名 centos_temp。注意必须选择为所有网卡重新生成 MAC 地址。然后在下一步中选择链接复制。 然后进行和之前相同的操作，使用 nmtui 修改主机名和第二块网卡IP地址。注意此时不可以和之前完全相同，例如我将地址设置为192.168.100.10/24，即前 24 位保持不变，使其位于同一子网下 测试两个虚拟机 完成以上配置后，我们同时启动两个虚拟机。在Windows主机上，应能 ping 通它们： 且能通过 ssh 访问两个虚拟机（使用git bash）。如下图所示，centos_base和centos_temp均可连接上： 配置用远程桌面访问你的虚拟机 详细教程见：如何设置VirtualBox虚拟机远程访问模式 简单来说，首先去官网下载VBox的拓展包 然后从VBox菜单的管理–&gt;全局设定–&gt;扩展中导入刚下载的扩展包。 然后右击虚拟机–&gt;设置–&gt;显示–&gt;远程桌面，启用服务器并自行设置好一个端口（两台虚拟机需要设置不同的端口号避免冲突），保存设置，然后启动该虚拟机。如下图，我设置的端口号为2629： 在Windows10中启动远程桌面程序，输入之前创建网卡的地址加上刚刚设置的端口号，连接，即可在宿主机上“远程使用”自己的centos虚拟机了。 同理，我另一个虚拟机使用的是3030端口： 可以看到，成功连接了centos_base和centos_temp两台虚拟机。 至此，实验完成。 实验难点(“坑”) 在使用Windows远程桌面连接虚拟机时，不可以想当然的去用我们刚刚为虚拟机配置的IP地址，而是要使用的是宿主机的IP地址，不是子机，即我们最初为VirtualBox配置的网卡IP地址：192.168.100.1。经过测试，我发现使用主机的自身IP地址（例如无线网卡地址也是可以的） 在虚拟机中对于 enp0s8 设置IP地址时，不要直接设置为我们最初设置的网卡地址192.168.100.1/24，而应该使其位于同一网段下即可，即保持前24位一致。否则，会出现ssh时无法连接的情况。 实验心得 之前也接触并使用过linux操作系统，但都仅限于编程，没有进行过如上所述的一些网络配置，收获还是挺大的，并且完成了远程云桌面的设置，对于实验的结果比较满意。 虽然整体的实验并不难，但也在一些小细节上卡了几次，比如就像连接远程桌面的时候，我使用了centos中设置的IP地址，导致无法连接上。在仔细阅读了老师给出的资料后，才发现原来是要使用宿主机的IP地址。 通过本次实验，让我体会到了配置环境的重要性，这是以后进一步学习的基石，让我收获很大。","categories":[{"name":"服务计算","slug":"服务计算","permalink":"http://yoursite.com/categories/服务计算/"}],"tags":[{"name":"云桌面","slug":"云桌面","permalink":"http://yoursite.com/tags/云桌面/"},{"name":"服务计算","slug":"服务计算","permalink":"http://yoursite.com/tags/服务计算/"},{"name":"CentOS","slug":"CentOS","permalink":"http://yoursite.com/tags/CentOS/"},{"name":"ssh","slug":"ssh","permalink":"http://yoursite.com/tags/ssh/"}]}]}